{"version":3,"sources":["turbopack:///[project]/src/lib/prisma.ts","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/flattened/verify.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/verify.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/validate_algorithms.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/compact/verify.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jwt/verify.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/flattened/sign.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/sign.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/compact/sign.js","turbopack:///[project]/node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jwt/sign.js","turbopack:///[project]/src/lib/painel-session.ts"],"sourcesContent":["// src/lib/prisma.ts\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n    prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n    globalForPrisma.prisma ??\n    new PrismaClient({\n        log:\n            process.env.NODE_ENV === 'development'\n                ? ['error', 'warn']\n                : ['error'],\n    });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n","import { decode as b64u } from '../../util/base64url.js';\nimport { verify } from '../../lib/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder, encode } from '../../lib/buffer_utils.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { isObject } from '../../lib/is_object.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { validateAlgorithms } from '../../lib/validate_algorithms.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = b64u(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(jws.protected !== undefined ? encode(jws.protected) : new Uint8Array(), encode('.'), typeof jws.payload === 'string'\n        ? b64\n            ? encode(jws.payload)\n            : encoder.encode(jws.payload)\n        : jws.payload);\n    let signature;\n    try {\n        signature = b64u(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const k = await normalizeKey(key, alg);\n    const verified = await verify(alg, k, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = b64u(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key: k };\n    }\n    return result;\n}\n","import { subtleAlgorithm } from './subtle_dsa.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { getSigKey } from './get_sign_verify_key.js';\nexport async function verify(alg, key, signature, data) {\n    const cryptoKey = await getSigKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch {\n        return false;\n    }\n}\n","export function validateAlgorithms(option, algorithms) {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n}\n","import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { compactVerify } from '../jws/compact/verify.js';\nimport { validateClaimsSet } from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    const verified = await compactVerify(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { encode as b64u } from '../../util/base64url.js';\nimport { sign } from '../../lib/sign.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { concat, encode } from '../../lib/buffer_utils.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payloadS;\n        let payloadB;\n        if (b64) {\n            payloadS = b64u(this.#payload);\n            payloadB = encode(payloadS);\n        }\n        else {\n            payloadB = this.#payload;\n            payloadS = '';\n        }\n        let protectedHeaderString;\n        let protectedHeaderBytes;\n        if (this.#protectedHeader) {\n            protectedHeaderString = b64u(JSON.stringify(this.#protectedHeader));\n            protectedHeaderBytes = encode(protectedHeaderString);\n        }\n        else {\n            protectedHeaderString = '';\n            protectedHeaderBytes = new Uint8Array();\n        }\n        const data = concat(protectedHeaderBytes, encode('.'), payloadB);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: payloadS,\n        };\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = protectedHeaderString;\n        }\n        return jws;\n    }\n}\n","import { subtleAlgorithm } from './subtle_dsa.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { getSigKey } from './get_sign_verify_key.js';\nexport async function sign(alg, key, data) {\n    const cryptoKey = await getSigKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","// src/lib/painel-session.ts\nimport { cookies, headers } from 'next/headers';\nimport { SignJWT, jwtVerify } from 'jose';\nimport { prisma } from '@/lib/prisma';\nimport type { AuthenticatedUser } from './auth';\n\nconst SESSION_COOKIE_NAME = 'painel_session';\nconst SESSION_MAX_AGE_SECONDS = 60 * 60 * 8; // 8h\nconst DEV_DEFAULT_TENANT = 'atendeplay';\n\n// ✅ ajuste aqui se seu domínio base for diferente\nconst BASE_DOMAIN = 'atendeplay.com.br';\n// ✅ cookie compartilhado por subdomínios em produção\nconst COOKIE_DOMAIN_PROD = `.${BASE_DOMAIN}`;\n\nfunction getJwtSecretKey() {\n    const secret = process.env.PAINEL_JWT_SECRET;\n    if (!secret) throw new Error('PAINEL_JWT_SECRET não definido no .env');\n    return new TextEncoder().encode(secret);\n}\n\n/**\n * Pega o host \"real\" da requisição, respeitando proxies.\n * - Vercel/Cloudflare/Nginx normalmente setam x-forwarded-host\n * - Pode vir como lista separada por vírgula\n */\nfunction getHostFromHeaders(h: Headers): string {\n    const xfHost =\n        h.get('x-forwarded-host') ||\n        h.get('x-original-host') ||\n        h.get('x-vercel-forwarded-host') ||\n        '';\n\n    const raw = (xfHost || h.get('host') || '').trim().toLowerCase();\n\n    // pode vir \"a.com, b.com\"\n    const first = raw.split(',')[0]?.trim() ?? '';\n    return first.split(':')[0]; // remove :3000\n}\n\n/**\n * Detecta se a requisição está chegando via HTTPS (mesmo atrás de proxy).\n */\nfunction isHttpsFromHeaders(h: Headers): boolean {\n    // padrão em proxies (Vercel/Nginx/Ingress)\n    const xfProtoRaw = (h.get('x-forwarded-proto') || '').toLowerCase();\n    const xfProto = xfProtoRaw.split(',')[0]?.trim() ?? '';\n\n    if (xfProto === 'https') return true;\n    if (xfProto === 'http') return false;\n\n    // Cloudflare\n    const cfVisitor = h.get('cf-visitor');\n    if (cfVisitor && cfVisitor.toLowerCase().includes('\"scheme\":\"https\"')) {\n        return true;\n    }\n\n    // alguns proxies setam isso\n    const xfSsl = (h.get('x-forwarded-ssl') || '').toLowerCase();\n    if (xfSsl === 'on') return true;\n\n    // fallback: se não sabemos, assume false\n    return false;\n}\n\n/**\n * Define o domain do cookie somente quando o host pertence ao BASE_DOMAIN.\n * Isso evita quebrar login em preview/staging (ex: *.vercel.app, IP, etc).\n */\nfunction getCookieDomainForHost(host: string): string | undefined {\n    const cleanHost = String(host || '')\n        .trim()\n        .toLowerCase();\n    if (!cleanHost) return undefined;\n\n    // localhost nunca usa domain\n    if (cleanHost === 'localhost' || cleanHost.endsWith('.localhost')) {\n        return undefined;\n    }\n\n    // só aplica o domain compartilhado se for realmente do domínio base\n    if (cleanHost === BASE_DOMAIN || cleanHost.endsWith(`.${BASE_DOMAIN}`)) {\n        return COOKIE_DOMAIN_PROD;\n    }\n\n    return undefined;\n}\n\n/**\n * Resolve tenant slug pelo subdomínio:\n * clientea.atendeplay.com.br => \"clientea\"\n */\nfunction getTenantSlugFromHost(host: string): string | null {\n    const cleanHost = String(host || '')\n        .trim()\n        .toLowerCase()\n        .split(':')[0];\n\n    if (!cleanHost) return null;\n\n    // ✅ DEV: localhost e *.localhost usam tenant padrão\n    if (cleanHost === 'localhost' || cleanHost.endsWith('.localhost')) {\n        return DEV_DEFAULT_TENANT;\n    }\n\n    // ✅ domínio raiz não tem tenant (evita tratar \"atendeplay\" como tenant)\n    if (cleanHost === BASE_DOMAIN || cleanHost === `www.${BASE_DOMAIN}`) {\n        return null;\n    }\n\n    // ✅ padrão oficial: <tenant>.atendeplay.com.br\n    if (cleanHost.endsWith(`.${BASE_DOMAIN}`)) {\n        const sub = cleanHost.slice(0, -`.${BASE_DOMAIN}`.length);\n        const parts = sub.split('.').filter(Boolean);\n\n        // ignora www caso exista (www.clientea.atendeplay.com.br)\n        const first = parts[0] === 'www' ? parts[1] : parts[0];\n        return first ? String(first) : null;\n    }\n\n    /**\n     * Fallback genérico (caso você use outros domínios)\n     * Regras:\n     * - precisa ter pelo menos 3 partes para \"subdomínio + domínio + tld\"\n     * - ignora www\n     */\n    const parts = cleanHost.split('.').filter(Boolean);\n    if (parts.length < 3) return null;\n\n    const first = parts[0] === 'www' ? parts[1] : parts[0];\n    return first ? String(first) : null;\n}\n\nasync function getTenantSlugFromRequestHeaders(): Promise<string> {\n    const h = await headers();\n    const host = getHostFromHeaders(h);\n\n    const slug = getTenantSlugFromHost(host);\n\n    // ✅ em prod, sem tenant = sem painel de empresa\n    if (!slug) throw new Error('tenant_not_found');\n\n    return slug;\n}\n\nexport type PainelRole =\n    | 'ADMIN'\n    | 'PROFESSIONAL'\n    | 'PLATFORM_OWNER'\n    | 'PLATFORM_STAFF';\n\nexport type PainelSessionPayload = {\n    sub: string; // userId\n    role: PainelRole;\n    email: string;\n    name?: string | null;\n\n    /**\n     * ✅ Tenant-only fields\n     * (Admin/Professional)\n     */\n    tenantSlug?: string;\n    companyId?: string;\n\n    unitId?: string | null;\n    canSeeAllUnits?: boolean;\n\n    professionalId?: string | null;\n};\n\nfunction isPlatformRole(role: string) {\n    const r = String(role || '').toUpperCase();\n    return r === 'PLATFORM_OWNER' || r === 'PLATFORM_STAFF';\n}\n\nfunction isTenantRole(role: string) {\n    const r = String(role || '').toUpperCase();\n    return r === 'ADMIN' || r === 'PROFESSIONAL';\n}\n\nasync function resolveCompanyByTenantSlug(tenantSlug: string) {\n    const company = await prisma.company.findFirst({\n        where: { slug: tenantSlug, isActive: true },\n        select: { id: true, slug: true },\n    });\n\n    if (!company?.id) throw new Error('missing_company');\n    return {\n        companyId: String(company.id),\n        tenantSlug: String(company.slug ?? tenantSlug),\n    };\n}\n\n/**\n * Resolve PROFESSIONAL dentro da company do tenant.\n * - Preferência: userId\n * - Fallback: email\n * - unitId automático se houver 1 unidade ativa\n */\nasync function resolveProfessionalContext(params: {\n    companyId: string;\n    userId: string;\n    email: string;\n}): Promise<{\n    professionalId: string;\n    unitId: string | null;\n} | null> {\n    const select = {\n        id: true,\n        units: {\n            where: { isActive: true },\n            select: { unitId: true },\n        },\n    } as const;\n\n    const byUserId = params.userId\n        ? await prisma.professional.findFirst({\n              where: {\n                  companyId: params.companyId,\n                  userId: params.userId,\n                  isActive: true,\n              },\n              select,\n          })\n        : null;\n\n    const prof =\n        byUserId ??\n        (params.email\n            ? await prisma.professional.findFirst({\n                  where: {\n                      companyId: params.companyId,\n                      email: params.email,\n                      isActive: true,\n                  },\n                  select,\n              })\n            : null);\n\n    if (!prof?.id) return null;\n\n    const unitIds = prof.units.map((u) => String(u.unitId)).filter(Boolean);\n    const unitId = unitIds.length === 1 ? unitIds[0] : null;\n\n    return {\n        professionalId: String(prof.id),\n        unitId,\n    };\n}\n\ntype AdminAccessPerms = {\n    canAccessDashboard: boolean;\n    canAccessReports: boolean;\n    canAccessCheckout: boolean;\n    canAccessAppointments: boolean;\n    canAccessProfessionals: boolean;\n    canAccessServices: boolean;\n    canAccessReviews: boolean;\n    canAccessProducts: boolean;\n    canAccessClients: boolean;\n    canAccessClientLevels: boolean;\n    canAccessFinance: boolean;\n    canAccessSettings: boolean;\n};\n\nfunction defaultAdminPerms(): AdminAccessPerms {\n    // ✅ defaults do painel (mesmos que você usa na UI)\n    return {\n        canAccessDashboard: true,\n        canAccessReports: false,\n        canAccessCheckout: false,\n        canAccessAppointments: true,\n        canAccessProfessionals: false,\n        canAccessServices: false,\n        canAccessReviews: false,\n        canAccessProducts: false,\n        canAccessClients: true,\n        canAccessClientLevels: false,\n        canAccessFinance: false,\n        canAccessSettings: false,\n    };\n}\n\nexport async function createSessionToken(\n    user: AuthenticatedUser\n): Promise<string> {\n    const userId = String(user.id ?? '').trim();\n    const email = String(user.email ?? '')\n        .trim()\n        .toLowerCase();\n    const name = user.name ?? null;\n\n    if (!userId) throw new Error('Sem acesso (id ausente).');\n    if (!email) throw new Error('Sem acesso (email ausente).');\n\n    const role = String(user.role || '').toUpperCase();\n\n    // ✅ PLATFORM: não depende de tenantSlug/companyId\n    if (isPlatformRole(role)) {\n        const payload: PainelSessionPayload = {\n            sub: userId,\n            role: role as PainelRole,\n            email,\n            name,\n        };\n\n        return await new SignJWT(payload)\n            .setProtectedHeader({ alg: 'HS256' })\n            .setIssuedAt()\n            .setExpirationTime(`${SESSION_MAX_AGE_SECONDS}s`)\n            .sign(getJwtSecretKey());\n    }\n\n    // ✅ Abaixo daqui: tenant-only (ADMIN / PROFESSIONAL)\n    if (!isTenantRole(role)) {\n        throw new Error('permissao');\n    }\n\n    // ✅ Tenant vem do host (com suporte a proxy em prod)\n    const tenantSlugFromHost = await getTenantSlugFromRequestHeaders();\n\n    // ✅ Company vem do tenantSlug\n    const { companyId, tenantSlug } =\n        await resolveCompanyByTenantSlug(tenantSlugFromHost);\n\n    // ===== ADMIN =====\n    if (role === 'ADMIN') {\n        const dbUser = await prisma.user.findUnique({\n            where: { id: userId },\n            select: {\n                adminAccesses: {\n                    where: { companyId },\n                    select: {\n                        companyId: true,\n                        unitId: true,\n                        canAccessDashboard: true,\n                        canAccessReports: true,\n                        canAccessCheckout: true,\n                        canAccessAppointments: true,\n                        canAccessProfessionals: true,\n                        canAccessServices: true,\n                        canAccessReviews: true,\n                        canAccessProducts: true,\n                        canAccessClients: true,\n                        canAccessClientLevels: true,\n                        canAccessFinance: true,\n                        canAccessSettings: true,\n                    },\n                },\n                companyMemberships: {\n                    where: { isActive: true, companyId },\n                    select: { companyId: true, role: true },\n                },\n            },\n        });\n\n        if (!dbUser) throw new Error('Sem acesso');\n\n        const membership = dbUser.companyMemberships?.[0] ?? null;\n        const access0 = dbUser.adminAccesses?.[0] ?? null;\n\n        // Precisa ter vínculo com a company do tenant\n        if (!membership && !access0) {\n            throw new Error('missing_company');\n        }\n\n        const isOwner = String(membership?.role ?? '') === 'OWNER';\n\n        // OWNER: vê tudo\n        if (isOwner) {\n            const payload: PainelSessionPayload = {\n                sub: userId,\n                role: 'ADMIN',\n                email,\n                name,\n                tenantSlug,\n                companyId,\n                unitId: null,\n                canSeeAllUnits: true,\n            };\n\n            return await new SignJWT(payload)\n                .setProtectedHeader({ alg: 'HS256' })\n                .setIssuedAt()\n                .setExpirationTime(`${SESSION_MAX_AGE_SECONDS}s`)\n                .sign(getJwtSecretKey());\n        }\n\n        // ADMIN configurável: precisa ter membership na company do tenant\n        if (!membership) {\n            throw new Error('missing_company');\n        }\n\n        let access = access0;\n\n        // ✅ auto-heal: cria adminAccess se não existir\n        if (!access) {\n            const created = await prisma.adminAccess.create({\n                data: {\n                    companyId,\n                    userId,\n                    unitId: null,\n                    ...defaultAdminPerms(),\n                } as any,\n                select: {\n                    companyId: true,\n                    unitId: true,\n                    canAccessDashboard: true,\n                    canAccessReports: true,\n                    canAccessCheckout: true,\n                    canAccessAppointments: true,\n                    canAccessProfessionals: true,\n                    canAccessServices: true,\n                    canAccessReviews: true,\n                    canAccessProducts: true,\n                    canAccessClients: true,\n                    canAccessClientLevels: true,\n                    canAccessFinance: true,\n                    canAccessSettings: true,\n                },\n            });\n\n            access = created as any;\n        }\n\n        const payload: PainelSessionPayload = {\n            sub: userId,\n            role: 'ADMIN',\n            email,\n            name,\n            tenantSlug,\n            companyId,\n            unitId: access.unitId == null ? null : String(access.unitId),\n            canSeeAllUnits: false,\n        };\n\n        return await new SignJWT(payload)\n            .setProtectedHeader({ alg: 'HS256' })\n            .setIssuedAt()\n            .setExpirationTime(`${SESSION_MAX_AGE_SECONDS}s`)\n            .sign(getJwtSecretKey());\n    }\n\n    // ===== PROFESSIONAL =====\n    if (role !== 'PROFESSIONAL') {\n        throw new Error('permissao');\n    }\n\n    const professionalCtx = await resolveProfessionalContext({\n        companyId,\n        userId,\n        email,\n    });\n\n    if (!professionalCtx) {\n        throw new Error('permissao');\n    }\n\n    const payload: PainelSessionPayload = {\n        sub: userId,\n        role: 'PROFESSIONAL',\n        email,\n        name,\n        tenantSlug,\n        companyId,\n        unitId: professionalCtx.unitId,\n        canSeeAllUnits: false,\n        professionalId: professionalCtx.professionalId,\n    };\n\n    return await new SignJWT(payload)\n        .setProtectedHeader({ alg: 'HS256' })\n        .setIssuedAt()\n        .setExpirationTime(`${SESSION_MAX_AGE_SECONDS}s`)\n        .sign(getJwtSecretKey());\n}\n\nexport async function verifySessionToken(\n    token: string\n): Promise<PainelSessionPayload | null> {\n    try {\n        const { payload } = await jwtVerify(token, getJwtSecretKey());\n        const p = payload as any;\n\n        const role = String(p?.role ?? '').toUpperCase();\n\n        const isValidRole =\n            role === 'ADMIN' ||\n            role === 'PROFESSIONAL' ||\n            role === 'PLATFORM_OWNER' ||\n            role === 'PLATFORM_STAFF';\n\n        if (!isValidRole) return null;\n\n        const base: PainelSessionPayload = {\n            sub: String(p?.sub ?? ''),\n            role: role as PainelRole,\n            email: String(p?.email ?? ''),\n            name: (p?.name ?? null) as string | null,\n            unitId: p?.unitId == null ? null : String(p.unitId),\n            canSeeAllUnits:\n                typeof p?.canSeeAllUnits === 'boolean'\n                    ? p.canSeeAllUnits\n                    : undefined,\n            professionalId:\n                p?.professionalId == null ? null : String(p.professionalId),\n        };\n\n        if (isPlatformRole(role)) {\n            if (!base.sub || !base.email) return null;\n            return base;\n        }\n\n        const tenantSlug = String(p?.tenantSlug ?? '')\n            .trim()\n            .toLowerCase();\n        const companyId = String(p?.companyId ?? '').trim();\n\n        if (!tenantSlug || !companyId) return null;\n\n        return {\n            ...base,\n            tenantSlug,\n            companyId,\n        };\n    } catch {\n        return null;\n    }\n}\n\nexport async function getCurrentPainelUser(): Promise<PainelSessionPayload | null> {\n    const cookieStore = await cookies();\n    const token = cookieStore.get(SESSION_COOKIE_NAME)?.value;\n    if (!token) return null;\n    return await verifySessionToken(token);\n}\n\nexport async function createPainelSessionCookie(user: AuthenticatedUser) {\n    const token = await createSessionToken(user);\n    const cookieStore = await cookies();\n\n    const h = await headers();\n    const host = getHostFromHeaders(h);\n    const secure = isHttpsFromHeaders(h);\n    const domain = getCookieDomainForHost(host);\n\n    cookieStore.set(SESSION_COOKIE_NAME, token, {\n        httpOnly: true,\n        // ✅ só marca Secure se a request realmente estiver em HTTPS\n        secure,\n        sameSite: 'lax',\n        path: '/',\n        maxAge: SESSION_MAX_AGE_SECONDS,\n        // ✅ só força domain quando for o domínio real\n        domain,\n    });\n}\n\nexport async function clearPainelSessionCookie() {\n    const cookieStore = await cookies();\n\n    const h = await headers();\n    const host = getHostFromHeaders(h);\n    const secure = isHttpsFromHeaders(h);\n    const domain = getCookieDomainForHost(host);\n\n    // ✅ expira com o mesmo domain/path para garantir remoção\n    cookieStore.set(SESSION_COOKIE_NAME, '', {\n        httpOnly: true,\n        secure,\n        sameSite: 'lax',\n        path: '/',\n        maxAge: 0,\n        domain,\n    });\n\n    // fallback\n    cookieStore.delete(SESSION_COOKIE_NAME);\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9]}