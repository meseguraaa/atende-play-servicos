{"version":3,"sources":["turbopack:///[project]/src/lib/admin-permissions.ts","turbopack:///[project]/src/app/admin/client-level/config/ui-client.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/app/admin/client-level/config/page.tsx"],"sourcesContent":["// src/lib/admin-permissions.ts\nimport { redirect } from 'next/navigation';\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { getCurrentPainelUser } from '@/lib/painel-session';\n\n/* =========================================================\n * Admin (Tenant)\n * ========================================================= */\n\nexport type AdminModule =\n    | 'DASHBOARD'\n    | 'REPORTS'\n    | 'CHECKOUT'\n    | 'APPOINTMENTS'\n    | 'PROFESSIONALS'\n    | 'SERVICES'\n    | 'REVIEWS'\n    | 'PRODUCTS'\n    | 'PARTNERS'\n    | 'CLIENTS'\n    | 'CLIENT_LEVELS'\n    | 'FINANCE'\n    | 'SETTINGS';\n\nexport type AdminSession = {\n    id: string;\n    name: string | null;\n    email: string;\n    role: 'ADMIN';\n    isOwner: boolean;\n    companyId: string;\n\n    // ✅ Multi-unidade fica para depois\n    unitId: null;\n\n    // ✅ Multi-unidade fica para depois (por enquanto sempre true pro owner e false pro resto)\n    canSeeAllUnits: boolean;\n};\n\ntype AdminAccessFlag =\n    | 'canAccessDashboard'\n    | 'canAccessReports'\n    | 'canAccessCheckout'\n    | 'canAccessAppointments'\n    | 'canAccessProfessionals'\n    | 'canAccessServices'\n    | 'canAccessReviews'\n    | 'canAccessProducts'\n    | 'canAccessPartners'\n    | 'canAccessClients'\n    | 'canAccessClientLevels'\n    | 'canAccessFinance'\n    | 'canAccessSettings';\n\ntype AdminAccessSelect = Record<AdminAccessFlag, true>;\nconst ADMIN_ACCESS_SELECT: AdminAccessSelect = {\n    canAccessDashboard: true,\n    canAccessReports: true,\n    canAccessCheckout: true,\n    canAccessAppointments: true,\n    canAccessProfessionals: true,\n    canAccessServices: true,\n    canAccessReviews: true,\n    canAccessProducts: true,\n    canAccessPartners: true,\n    canAccessClients: true,\n    canAccessClientLevels: true,\n    canAccessFinance: true,\n    canAccessSettings: true,\n};\n\nfunction moduleToAccessField(module: AdminModule): AdminAccessFlag | null {\n    switch (module) {\n        case 'DASHBOARD':\n            return 'canAccessDashboard';\n        case 'REPORTS':\n            return 'canAccessReports';\n        case 'CHECKOUT':\n            return 'canAccessCheckout';\n        case 'APPOINTMENTS':\n            return 'canAccessAppointments';\n        case 'PROFESSIONALS':\n            return 'canAccessProfessionals';\n        case 'SERVICES':\n            return 'canAccessServices';\n        case 'REVIEWS':\n            return 'canAccessReviews';\n        case 'PRODUCTS':\n            return 'canAccessProducts';\n\n        // ✅ IMPORTANTE:\n        // Parceiros saiu do ADMIN (tenant) e agora pertence somente à PLATAFORMA.\n        // Ao retornar null, o guard força redirect para o primeiro módulo permitido.\n        case 'PARTNERS':\n            return null;\n\n        case 'CLIENTS':\n            return 'canAccessClients';\n        case 'CLIENT_LEVELS':\n            return 'canAccessClientLevels';\n        case 'FINANCE':\n            return 'canAccessFinance';\n        case 'SETTINGS':\n            return 'canAccessSettings';\n        default:\n            return null;\n    }\n}\n\ntype AdminContext = {\n    id: string;\n    name: string | null;\n    email: string;\n    companyId: string;\n    isOwner: boolean;\n};\n\ntype AdminContextResult =\n    | { ok: true; ctx: AdminContext }\n    | {\n          ok: false;\n          reason:\n              | 'no_session'\n              | 'not_admin'\n              | 'invalid_token'\n              | 'user_inactive'\n              | 'no_membership'\n              | 'no_access';\n      };\n\ntype AdminContextFailureReason = Extract<\n    AdminContextResult,\n    { ok: false }\n>['reason'];\n\nasync function getAdminContext(): Promise<AdminContextResult> {\n    const session = await getCurrentPainelUser();\n\n    if (!session) return { ok: false, reason: 'no_session' };\n\n    // ✅ IMPORTANTE: aqui é TENANT ADMIN apenas\n    if (session.role !== 'ADMIN') return { ok: false, reason: 'not_admin' };\n\n    const userId = String((session as any).sub || '').trim();\n    const companyId = String((session as any).companyId || '').trim();\n\n    if (!userId || !companyId) return { ok: false, reason: 'invalid_token' };\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: { id: true, name: true, email: true, isActive: true },\n    });\n\n    if (!user?.id || !user.isActive) {\n        return { ok: false, reason: 'user_inactive' };\n    }\n\n    const membership = await prisma.companyMember.findFirst({\n        where: {\n            userId,\n            companyId,\n            isActive: true,\n            role: { in: ['OWNER', 'ADMIN'] },\n        },\n        select: { role: true },\n    });\n\n    if (!membership?.role) return { ok: false, reason: 'no_membership' };\n\n    const isOwner = membership.role === 'OWNER';\n\n    // ✅ Sub-admin precisa existir em AdminAccess (OWNER não precisa)\n    if (!isOwner) {\n        const accessExists = await prisma.adminAccess.findFirst({\n            where: { userId, companyId },\n            select: { id: true },\n        });\n\n        if (!accessExists?.id) return { ok: false, reason: 'no_access' };\n    }\n\n    return {\n        ok: true,\n        ctx: {\n            id: user.id,\n            name: user.name ?? null,\n            email: user.email,\n            companyId,\n            isOwner,\n        },\n    };\n}\n\nfunction redirectToLoginByReason(reason: AdminContextFailureReason): never {\n    switch (reason) {\n        case 'no_session':\n            redirect('/painel/login?error=credenciais');\n        case 'not_admin':\n            redirect('/painel/login?error=permissao');\n        case 'invalid_token':\n        case 'user_inactive':\n        case 'no_membership':\n        case 'no_access':\n        default:\n            redirect('/painel/login?error=permissao');\n    }\n}\n\ntype ModuleRoute = { module: AdminModule; href: string };\n\n/**\n * ✅ Ordem de “melhor destino” quando falta permissão.\n *\n * Mantemos DASHBOARD por último (se for o único liberado, vira fallback final).\n * O restante segue a ordem do menu que você pediu.\n */\nconst FALLBACK_ROUTES: ModuleRoute[] = [\n    { module: 'APPOINTMENTS', href: '/admin/appointments' },\n    { module: 'CHECKOUT', href: '/admin/checkout' },\n    {\n        module: 'PROFESSIONALS',\n        // ✅ FIX: rota correta (plural)\n        href: '/admin/professionals',\n    },\n    { module: 'SERVICES', href: '/admin/services' },\n    { module: 'PRODUCTS', href: '/admin/products' },\n\n    // ✅ PARTNERS REMOVIDO do fallback (agora é somente da PLATAFORMA)\n\n    { module: 'CLIENTS', href: '/admin/clients' },\n    { module: 'CLIENT_LEVELS', href: '/admin/client-levels' },\n    { module: 'REVIEWS', href: '/admin/review-tags' },\n    { module: 'REPORTS', href: '/admin/reports' },\n    { module: 'FINANCE', href: '/admin/finance' },\n    { module: 'SETTINGS', href: '/admin/setting' },\n    // deixa dashboard por último\n    { module: 'DASHBOARD', href: '/admin/dashboard' },\n];\n\nfunction pickFirstAllowedHref(\n    access: Record<string, any> | null\n): string | null {\n    if (!access) return null;\n\n    for (const r of FALLBACK_ROUTES) {\n        const flag = moduleToAccessField(r.module);\n        if (!flag) continue;\n        if (Boolean((access as any)[flag])) return r.href;\n    }\n\n    return null;\n}\n\nasync function redirectToFirstAllowedOrLogin(params: {\n    companyId: string;\n    userId: string;\n}): Promise<never> {\n    const access = await prisma.adminAccess.findFirst({\n        where: { companyId: params.companyId, userId: params.userId },\n        select: ADMIN_ACCESS_SELECT,\n    });\n\n    const href = pickFirstAllowedHref(access as any);\n    if (href) {\n        redirect(`${href}?error=permissao`);\n        throw new Error('unreachable');\n    }\n\n    redirect('/painel/login?error=permissao');\n    throw new Error('unreachable');\n}\n\n/**\n * ✅ Server Components / Layouts / Pages (bloqueia com redirect)\n */\nexport async function requireAdminForModule(\n    module: AdminModule\n): Promise<AdminSession> {\n    const res = await getAdminContext();\n\n    if (!res.ok) {\n        redirectToLoginByReason(res.reason);\n    }\n\n    const ctx = res.ctx;\n\n    // OWNER: tudo liberado (mas mesmo assim, PARTNERS não existe mais no Admin)\n    if (ctx.isOwner) {\n        // ✅ Se tentarem acessar PARTNERS como admin-owner tenant, cai no redirect padrão\n        if (module === 'PARTNERS') {\n            await redirectToFirstAllowedOrLogin({\n                companyId: ctx.companyId,\n                userId: ctx.id,\n            });\n            throw new Error('unreachable');\n        }\n\n        return {\n            id: ctx.id,\n            name: ctx.name,\n            email: ctx.email,\n            role: 'ADMIN',\n            isOwner: true,\n            companyId: ctx.companyId,\n            unitId: null,\n            canSeeAllUnits: true,\n        };\n    }\n\n    const accessField = moduleToAccessField(module);\n    if (!accessField) {\n        await redirectToFirstAllowedOrLogin({\n            companyId: ctx.companyId,\n            userId: ctx.id,\n        });\n        throw new Error('unreachable');\n    }\n\n    const access = await prisma.adminAccess.findFirst({\n        where: { userId: ctx.id, companyId: ctx.companyId },\n        select: ADMIN_ACCESS_SELECT,\n    });\n\n    if (!access) {\n        await redirectToFirstAllowedOrLogin({\n            companyId: ctx.companyId,\n            userId: ctx.id,\n        });\n        throw new Error('unreachable');\n    }\n\n    const allowed = Boolean(access[accessField]);\n    if (!allowed) {\n        await redirectToFirstAllowedOrLogin({\n            companyId: ctx.companyId,\n            userId: ctx.id,\n        });\n        throw new Error('unreachable');\n    }\n\n    return {\n        id: ctx.id,\n        name: ctx.name,\n        email: ctx.email,\n        role: 'ADMIN',\n        isOwner: false,\n        companyId: ctx.companyId,\n        unitId: null,\n        canSeeAllUnits: false,\n    };\n}\n\n/**\n * ✅ Route Handlers /api (bloqueia com 403 JSON)\n *\n * Uso:\n * const res = await requireAdminForModuleApi('DASHBOARD');\n * if (res instanceof NextResponse) return res;\n * const session = res;\n */\nexport async function requireAdminForModuleApi(\n    module: AdminModule\n): Promise<AdminSession | NextResponse> {\n    const res = await getAdminContext();\n\n    if (!res.ok) {\n        return NextResponse.json(\n            { ok: false, error: 'unauthorized' },\n            { status: 401 }\n        );\n    }\n\n    const ctx = res.ctx;\n\n    if (ctx.isOwner) {\n        // ✅ trava PARTNERS também na API do Admin\n        if (module === 'PARTNERS') {\n            return NextResponse.json(\n                { ok: false, error: 'forbidden' },\n                { status: 403 }\n            );\n        }\n\n        return {\n            id: ctx.id,\n            name: ctx.name,\n            email: ctx.email,\n            role: 'ADMIN',\n            isOwner: true,\n            companyId: ctx.companyId,\n            unitId: null,\n            canSeeAllUnits: true,\n        };\n    }\n\n    const accessField = moduleToAccessField(module);\n    if (!accessField) {\n        return NextResponse.json(\n            { ok: false, error: 'forbidden' },\n            { status: 403 }\n        );\n    }\n\n    const access = await prisma.adminAccess.findFirst({\n        where: { userId: ctx.id, companyId: ctx.companyId },\n        select: ADMIN_ACCESS_SELECT,\n    });\n\n    if (!access || !Boolean(access[accessField])) {\n        const fallbackHref = pickFirstAllowedHref(access as any);\n        return NextResponse.json(\n            { ok: false, error: 'forbidden', fallback: fallbackHref },\n            { status: 403 }\n        );\n    }\n\n    return {\n        id: ctx.id,\n        name: ctx.name,\n        email: ctx.email,\n        role: 'ADMIN',\n        isOwner: false,\n        companyId: ctx.companyId,\n        unitId: null,\n        canSeeAllUnits: false,\n    };\n}\n\n/* =========================================================\n * Platform (AtendePlay)\n * ========================================================= *\n * ✅ MOVED OUT:\n * A plataforma agora vive em src/lib/platform-permissions.ts\n * Mantemos re-export aqui por compat (caso algum import antigo exista).\n */\n\nexport type {\n    PlatformModule,\n    PlatformSession,\n} from '@/lib/plataform-permissions';\nexport {\n    requirePlatformForModule,\n    requirePlatformForModuleApi,\n} from '@/lib/plataform-permissions';\n\n/**\n * Mantive esse export porque você já usou em outros pontos.\n * Implementamos de verdade quando chegar no painel do profissional.\n */\nexport async function requireProfessionalSession(): Promise<never> {\n    throw new Error(\n        'requireProfessionalSession ainda não foi implementado (não é necessário neste passo).'\n    );\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/admin/client-level/config/ui-client.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/admin/client-level/config/ui-client.tsx\",\n    \"default\",\n);\n","// src/app/admin/client-levels/config/page.tsx\nimport type { Metadata } from 'next';\nimport { headers } from 'next/headers';\n\nimport { requireAdminForModule } from '@/lib/admin-permissions';\n\nimport AdminClientLevelsConfigClient from './ui-client';\n\nexport const dynamic = 'force-dynamic';\n\nexport const metadata: Metadata = {\n    title: 'Admin | Nível de Cliente | Configurações',\n};\n\ntype LevelKey = 'BRONZE' | 'PRATA' | 'OURO' | 'DIAMANTE';\n\ntype UnitUI = {\n    id: string;\n    name: string;\n    isActive: boolean;\n};\n\ntype LevelConfig = {\n    minAppointmentsDone: number;\n    minOrdersCompleted: number;\n};\n\ntype ApiPayload = {\n    scope: {\n        companyId: string;\n        canSeeAllUnits: boolean;\n        unitCookie: string;\n    };\n    units: UnitUI[];\n    activeUnitId: string;\n    levels: LevelKey[];\n    configByLevel: Partial<Record<LevelKey, LevelConfig>>;\n};\n\nasync function getOriginFromHeaders() {\n    const h = await headers();\n\n    const proto = h.get('x-forwarded-proto') ?? 'http';\n    const host = h.get('x-forwarded-host') ?? h.get('host') ?? 'localhost:3000';\n\n    return `${proto}://${host}`;\n}\n\nexport default async function AdminClientLevelsConfigPage({\n    searchParams,\n}: {\n    searchParams: Promise<Record<string, string | string[] | undefined>>;\n}) {\n    // ✅ gate de permissão\n    await requireAdminForModule('CLIENT_LEVELS');\n\n    const sp = await searchParams;\n    const unitIdRaw = sp.unitId;\n    const unitId = Array.isArray(unitIdRaw) ? unitIdRaw[0] : unitIdRaw;\n\n    const origin = await getOriginFromHeaders();\n    const url = new URL('/api/admin/client-levels/config', origin);\n    if (unitId) url.searchParams.set('unitId', unitId);\n\n    let data: ApiPayload | null = null;\n    let error: string | null = null;\n\n    try {\n        // ✅ MUITO IMPORTANTE:\n        // repassa cookies do request atual, senão o route handler vai achar que está deslogado\n        const h = await headers();\n        const cookieHeader = h.get('cookie') ?? '';\n\n        const res = await fetch(url.toString(), {\n            method: 'GET',\n            cache: 'no-store',\n            headers: {\n                Accept: 'application/json',\n                cookie: cookieHeader,\n            },\n        });\n\n        // Se caiu em redirect (ex: /painel/login), não tenta parsear JSON\n        if (res.status >= 300 && res.status < 400) {\n            error =\n                'Sessão não reconhecida na API (redirect). Verifique cookies/autenticação.';\n        } else {\n            const json = (await res.json()) as\n                | { ok: true; data: ApiPayload }\n                | { ok: false; error: string };\n\n            if (!res.ok || !json.ok) {\n                error =\n                    !json.ok && json.error\n                        ? json.error\n                        : 'Falha ao carregar dados.';\n            } else {\n                data = json.data;\n            }\n        }\n    } catch (e: any) {\n        error =\n            typeof e?.message === 'string'\n                ? e.message\n                : 'Falha ao carregar dados.';\n    }\n\n    return <AdminClientLevelsConfigClient error={error} initialData={data} />;\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}