/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * This file exports the `ServiceProfessional` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/library';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model ServiceProfessional
 *
 */
export type ServiceProfessionalModel =
    runtime.Types.Result.DefaultSelection<Prisma.$ServiceProfessionalPayload>;

export type AggregateServiceProfessional = {
    _count: ServiceProfessionalCountAggregateOutputType | null;
    _min: ServiceProfessionalMinAggregateOutputType | null;
    _max: ServiceProfessionalMaxAggregateOutputType | null;
};

export type ServiceProfessionalMinAggregateOutputType = {
    id: string | null;
    companyId: string | null;
    serviceId: string | null;
    professionalId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};

export type ServiceProfessionalMaxAggregateOutputType = {
    id: string | null;
    companyId: string | null;
    serviceId: string | null;
    professionalId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};

export type ServiceProfessionalCountAggregateOutputType = {
    id: number;
    companyId: number;
    serviceId: number;
    professionalId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};

export type ServiceProfessionalMinAggregateInputType = {
    id?: true;
    companyId?: true;
    serviceId?: true;
    professionalId?: true;
    createdAt?: true;
    updatedAt?: true;
};

export type ServiceProfessionalMaxAggregateInputType = {
    id?: true;
    companyId?: true;
    serviceId?: true;
    professionalId?: true;
    createdAt?: true;
    updatedAt?: true;
};

export type ServiceProfessionalCountAggregateInputType = {
    id?: true;
    companyId?: true;
    serviceId?: true;
    professionalId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};

export type ServiceProfessionalAggregateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which ServiceProfessional to aggregate.
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceProfessionals to fetch.
     */
    orderBy?:
        | Prisma.ServiceProfessionalOrderByWithRelationInput
        | Prisma.ServiceProfessionalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.ServiceProfessionalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ServiceProfessionals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceProfessionals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceProfessionals
     **/
    _count?: true | ServiceProfessionalCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceProfessionalMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceProfessionalMaxAggregateInputType;
};

export type GetServiceProfessionalAggregateType<
    T extends ServiceProfessionalAggregateArgs,
> = {
    [P in keyof T & keyof AggregateServiceProfessional]: P extends
        | '_count'
        | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateServiceProfessional[P]>
        : Prisma.GetScalarType<T[P], AggregateServiceProfessional[P]>;
};

export type ServiceProfessionalGroupByArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.ServiceProfessionalWhereInput;
    orderBy?:
        | Prisma.ServiceProfessionalOrderByWithAggregationInput
        | Prisma.ServiceProfessionalOrderByWithAggregationInput[];
    by:
        | Prisma.ServiceProfessionalScalarFieldEnum[]
        | Prisma.ServiceProfessionalScalarFieldEnum;
    having?: Prisma.ServiceProfessionalScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceProfessionalCountAggregateInputType | true;
    _min?: ServiceProfessionalMinAggregateInputType;
    _max?: ServiceProfessionalMaxAggregateInputType;
};

export type ServiceProfessionalGroupByOutputType = {
    id: string;
    companyId: string;
    serviceId: string;
    professionalId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ServiceProfessionalCountAggregateOutputType | null;
    _min: ServiceProfessionalMinAggregateOutputType | null;
    _max: ServiceProfessionalMaxAggregateOutputType | null;
};

type GetServiceProfessionalGroupByPayload<
    T extends ServiceProfessionalGroupByArgs,
> = Prisma.PrismaPromise<
    Array<
        Prisma.PickEnumerable<ServiceProfessionalGroupByOutputType, T['by']> & {
            [P in keyof T &
                keyof ServiceProfessionalGroupByOutputType]: P extends '_count'
                ? T[P] extends boolean
                    ? number
                    : Prisma.GetScalarType<
                          T[P],
                          ServiceProfessionalGroupByOutputType[P]
                      >
                : Prisma.GetScalarType<
                      T[P],
                      ServiceProfessionalGroupByOutputType[P]
                  >;
        }
    >
>;

export type ServiceProfessionalWhereInput = {
    AND?:
        | Prisma.ServiceProfessionalWhereInput
        | Prisma.ServiceProfessionalWhereInput[];
    OR?: Prisma.ServiceProfessionalWhereInput[];
    NOT?:
        | Prisma.ServiceProfessionalWhereInput
        | Prisma.ServiceProfessionalWhereInput[];
    id?: Prisma.StringFilter<'ServiceProfessional'> | string;
    companyId?: Prisma.StringFilter<'ServiceProfessional'> | string;
    serviceId?: Prisma.StringFilter<'ServiceProfessional'> | string;
    professionalId?: Prisma.StringFilter<'ServiceProfessional'> | string;
    createdAt?: Prisma.DateTimeFilter<'ServiceProfessional'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'ServiceProfessional'> | Date | string;
    professional?: Prisma.XOR<
        Prisma.ProfessionalScalarRelationFilter,
        Prisma.ProfessionalWhereInput
    >;
    company?: Prisma.XOR<
        Prisma.CompanyScalarRelationFilter,
        Prisma.CompanyWhereInput
    >;
    service?: Prisma.XOR<
        Prisma.ServiceScalarRelationFilter,
        Prisma.ServiceWhereInput
    >;
};

export type ServiceProfessionalOrderByWithRelationInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    serviceId?: Prisma.SortOrder;
    professionalId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    professional?: Prisma.ProfessionalOrderByWithRelationInput;
    company?: Prisma.CompanyOrderByWithRelationInput;
    service?: Prisma.ServiceOrderByWithRelationInput;
};

export type ServiceProfessionalWhereUniqueInput = Prisma.AtLeast<
    {
        id?: string;
        serviceId_professionalId?: Prisma.ServiceProfessionalServiceIdProfessionalIdCompoundUniqueInput;
        AND?:
            | Prisma.ServiceProfessionalWhereInput
            | Prisma.ServiceProfessionalWhereInput[];
        OR?: Prisma.ServiceProfessionalWhereInput[];
        NOT?:
            | Prisma.ServiceProfessionalWhereInput
            | Prisma.ServiceProfessionalWhereInput[];
        companyId?: Prisma.StringFilter<'ServiceProfessional'> | string;
        serviceId?: Prisma.StringFilter<'ServiceProfessional'> | string;
        professionalId?: Prisma.StringFilter<'ServiceProfessional'> | string;
        createdAt?:
            | Prisma.DateTimeFilter<'ServiceProfessional'>
            | Date
            | string;
        updatedAt?:
            | Prisma.DateTimeFilter<'ServiceProfessional'>
            | Date
            | string;
        professional?: Prisma.XOR<
            Prisma.ProfessionalScalarRelationFilter,
            Prisma.ProfessionalWhereInput
        >;
        company?: Prisma.XOR<
            Prisma.CompanyScalarRelationFilter,
            Prisma.CompanyWhereInput
        >;
        service?: Prisma.XOR<
            Prisma.ServiceScalarRelationFilter,
            Prisma.ServiceWhereInput
        >;
    },
    'id' | 'serviceId_professionalId'
>;

export type ServiceProfessionalOrderByWithAggregationInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    serviceId?: Prisma.SortOrder;
    professionalId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    _count?: Prisma.ServiceProfessionalCountOrderByAggregateInput;
    _max?: Prisma.ServiceProfessionalMaxOrderByAggregateInput;
    _min?: Prisma.ServiceProfessionalMinOrderByAggregateInput;
};

export type ServiceProfessionalScalarWhereWithAggregatesInput = {
    AND?:
        | Prisma.ServiceProfessionalScalarWhereWithAggregatesInput
        | Prisma.ServiceProfessionalScalarWhereWithAggregatesInput[];
    OR?: Prisma.ServiceProfessionalScalarWhereWithAggregatesInput[];
    NOT?:
        | Prisma.ServiceProfessionalScalarWhereWithAggregatesInput
        | Prisma.ServiceProfessionalScalarWhereWithAggregatesInput[];
    id?: Prisma.StringWithAggregatesFilter<'ServiceProfessional'> | string;
    companyId?:
        | Prisma.StringWithAggregatesFilter<'ServiceProfessional'>
        | string;
    serviceId?:
        | Prisma.StringWithAggregatesFilter<'ServiceProfessional'>
        | string;
    professionalId?:
        | Prisma.StringWithAggregatesFilter<'ServiceProfessional'>
        | string;
    createdAt?:
        | Prisma.DateTimeWithAggregatesFilter<'ServiceProfessional'>
        | Date
        | string;
    updatedAt?:
        | Prisma.DateTimeWithAggregatesFilter<'ServiceProfessional'>
        | Date
        | string;
};

export type ServiceProfessionalCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    professional: Prisma.ProfessionalCreateNestedOneWithoutServicesInput;
    company: Prisma.CompanyCreateNestedOneWithoutServiceProfessionalsInput;
    service: Prisma.ServiceCreateNestedOneWithoutProfessionalsInput;
};

export type ServiceProfessionalUncheckedCreateInput = {
    id?: string;
    companyId: string;
    serviceId: string;
    professionalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalUpdateInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    professional?: Prisma.ProfessionalUpdateOneRequiredWithoutServicesNestedInput;
    company?: Prisma.CompanyUpdateOneRequiredWithoutServiceProfessionalsNestedInput;
    service?: Prisma.ServiceUpdateOneRequiredWithoutProfessionalsNestedInput;
};

export type ServiceProfessionalUncheckedUpdateInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    serviceId?: Prisma.StringFieldUpdateOperationsInput | string;
    professionalId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalCreateManyInput = {
    id?: string;
    companyId: string;
    serviceId: string;
    professionalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalUpdateManyMutationInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalUncheckedUpdateManyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    serviceId?: Prisma.StringFieldUpdateOperationsInput | string;
    professionalId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalListRelationFilter = {
    every?: Prisma.ServiceProfessionalWhereInput;
    some?: Prisma.ServiceProfessionalWhereInput;
    none?: Prisma.ServiceProfessionalWhereInput;
};

export type ServiceProfessionalOrderByRelationAggregateInput = {
    _count?: Prisma.SortOrder;
};

export type ServiceProfessionalServiceIdProfessionalIdCompoundUniqueInput = {
    serviceId: string;
    professionalId: string;
};

export type ServiceProfessionalCountOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    serviceId?: Prisma.SortOrder;
    professionalId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type ServiceProfessionalMaxOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    serviceId?: Prisma.SortOrder;
    professionalId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type ServiceProfessionalMinOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    serviceId?: Prisma.SortOrder;
    professionalId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type ServiceProfessionalCreateNestedManyWithoutCompanyInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutCompanyInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ServiceProfessionalCreateWithoutCompanyInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyCompanyInputEnvelope;
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
};

export type ServiceProfessionalUncheckedCreateNestedManyWithoutCompanyInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutCompanyInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ServiceProfessionalCreateWithoutCompanyInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyCompanyInputEnvelope;
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
};

export type ServiceProfessionalUpdateManyWithoutCompanyNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutCompanyInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ServiceProfessionalCreateWithoutCompanyInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput[];
    upsert?:
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutCompanyInput
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyCompanyInputEnvelope;
    set?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    disconnect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    delete?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    update?:
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutCompanyInput
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutCompanyInput
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
};

export type ServiceProfessionalUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutCompanyInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ServiceProfessionalCreateWithoutCompanyInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutCompanyInput[];
    upsert?:
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutCompanyInput
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyCompanyInputEnvelope;
    set?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    disconnect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    delete?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    update?:
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutCompanyInput
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutCompanyInput
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
};

export type ServiceProfessionalCreateNestedManyWithoutProfessionalInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutProfessionalInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput
          >
        | Prisma.ServiceProfessionalCreateWithoutProfessionalInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyProfessionalInputEnvelope;
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
};

export type ServiceProfessionalUncheckedCreateNestedManyWithoutProfessionalInput =
    {
        create?:
            | Prisma.XOR<
                  Prisma.ServiceProfessionalCreateWithoutProfessionalInput,
                  Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput
              >
            | Prisma.ServiceProfessionalCreateWithoutProfessionalInput[]
            | Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput[];
        connectOrCreate?:
            | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput
            | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput[];
        createMany?: Prisma.ServiceProfessionalCreateManyProfessionalInputEnvelope;
        connect?:
            | Prisma.ServiceProfessionalWhereUniqueInput
            | Prisma.ServiceProfessionalWhereUniqueInput[];
    };

export type ServiceProfessionalUpdateManyWithoutProfessionalNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutProfessionalInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput
          >
        | Prisma.ServiceProfessionalCreateWithoutProfessionalInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput[];
    upsert?:
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutProfessionalInput
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutProfessionalInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyProfessionalInputEnvelope;
    set?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    disconnect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    delete?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    update?:
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutProfessionalInput
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutProfessionalInput[];
    updateMany?:
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutProfessionalInput
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutProfessionalInput[];
    deleteMany?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
};

export type ServiceProfessionalUncheckedUpdateManyWithoutProfessionalNestedInput =
    {
        create?:
            | Prisma.XOR<
                  Prisma.ServiceProfessionalCreateWithoutProfessionalInput,
                  Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput
              >
            | Prisma.ServiceProfessionalCreateWithoutProfessionalInput[]
            | Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput[];
        connectOrCreate?:
            | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput
            | Prisma.ServiceProfessionalCreateOrConnectWithoutProfessionalInput[];
        upsert?:
            | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutProfessionalInput
            | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutProfessionalInput[];
        createMany?: Prisma.ServiceProfessionalCreateManyProfessionalInputEnvelope;
        set?:
            | Prisma.ServiceProfessionalWhereUniqueInput
            | Prisma.ServiceProfessionalWhereUniqueInput[];
        disconnect?:
            | Prisma.ServiceProfessionalWhereUniqueInput
            | Prisma.ServiceProfessionalWhereUniqueInput[];
        delete?:
            | Prisma.ServiceProfessionalWhereUniqueInput
            | Prisma.ServiceProfessionalWhereUniqueInput[];
        connect?:
            | Prisma.ServiceProfessionalWhereUniqueInput
            | Prisma.ServiceProfessionalWhereUniqueInput[];
        update?:
            | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutProfessionalInput
            | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutProfessionalInput[];
        updateMany?:
            | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutProfessionalInput
            | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutProfessionalInput[];
        deleteMany?:
            | Prisma.ServiceProfessionalScalarWhereInput
            | Prisma.ServiceProfessionalScalarWhereInput[];
    };

export type ServiceProfessionalCreateNestedManyWithoutServiceInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutServiceInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput
          >
        | Prisma.ServiceProfessionalCreateWithoutServiceInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyServiceInputEnvelope;
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
};

export type ServiceProfessionalUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutServiceInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput
          >
        | Prisma.ServiceProfessionalCreateWithoutServiceInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyServiceInputEnvelope;
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
};

export type ServiceProfessionalUpdateManyWithoutServiceNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutServiceInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput
          >
        | Prisma.ServiceProfessionalCreateWithoutServiceInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput[];
    upsert?:
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutServiceInput
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyServiceInputEnvelope;
    set?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    disconnect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    delete?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    update?:
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutServiceInput
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutServiceInput
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
};

export type ServiceProfessionalUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ServiceProfessionalCreateWithoutServiceInput,
              Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput
          >
        | Prisma.ServiceProfessionalCreateWithoutServiceInput[]
        | Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput
        | Prisma.ServiceProfessionalCreateOrConnectWithoutServiceInput[];
    upsert?:
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutServiceInput
        | Prisma.ServiceProfessionalUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: Prisma.ServiceProfessionalCreateManyServiceInputEnvelope;
    set?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    disconnect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    delete?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    connect?:
        | Prisma.ServiceProfessionalWhereUniqueInput
        | Prisma.ServiceProfessionalWhereUniqueInput[];
    update?:
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutServiceInput
        | Prisma.ServiceProfessionalUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutServiceInput
        | Prisma.ServiceProfessionalUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
};

export type ServiceProfessionalCreateWithoutCompanyInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    professional: Prisma.ProfessionalCreateNestedOneWithoutServicesInput;
    service: Prisma.ServiceCreateNestedOneWithoutProfessionalsInput;
};

export type ServiceProfessionalUncheckedCreateWithoutCompanyInput = {
    id?: string;
    serviceId: string;
    professionalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalCreateOrConnectWithoutCompanyInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateWithoutCompanyInput,
        Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput
    >;
};

export type ServiceProfessionalCreateManyCompanyInputEnvelope = {
    data:
        | Prisma.ServiceProfessionalCreateManyCompanyInput
        | Prisma.ServiceProfessionalCreateManyCompanyInput[];
    skipDuplicates?: boolean;
};

export type ServiceProfessionalUpsertWithWhereUniqueWithoutCompanyInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateWithoutCompanyInput,
        Prisma.ServiceProfessionalUncheckedUpdateWithoutCompanyInput
    >;
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateWithoutCompanyInput,
        Prisma.ServiceProfessionalUncheckedCreateWithoutCompanyInput
    >;
};

export type ServiceProfessionalUpdateWithWhereUniqueWithoutCompanyInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateWithoutCompanyInput,
        Prisma.ServiceProfessionalUncheckedUpdateWithoutCompanyInput
    >;
};

export type ServiceProfessionalUpdateManyWithWhereWithoutCompanyInput = {
    where: Prisma.ServiceProfessionalScalarWhereInput;
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateManyMutationInput,
        Prisma.ServiceProfessionalUncheckedUpdateManyWithoutCompanyInput
    >;
};

export type ServiceProfessionalScalarWhereInput = {
    AND?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
    OR?: Prisma.ServiceProfessionalScalarWhereInput[];
    NOT?:
        | Prisma.ServiceProfessionalScalarWhereInput
        | Prisma.ServiceProfessionalScalarWhereInput[];
    id?: Prisma.StringFilter<'ServiceProfessional'> | string;
    companyId?: Prisma.StringFilter<'ServiceProfessional'> | string;
    serviceId?: Prisma.StringFilter<'ServiceProfessional'> | string;
    professionalId?: Prisma.StringFilter<'ServiceProfessional'> | string;
    createdAt?: Prisma.DateTimeFilter<'ServiceProfessional'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'ServiceProfessional'> | Date | string;
};

export type ServiceProfessionalCreateWithoutProfessionalInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    company: Prisma.CompanyCreateNestedOneWithoutServiceProfessionalsInput;
    service: Prisma.ServiceCreateNestedOneWithoutProfessionalsInput;
};

export type ServiceProfessionalUncheckedCreateWithoutProfessionalInput = {
    id?: string;
    companyId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalCreateOrConnectWithoutProfessionalInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateWithoutProfessionalInput,
        Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput
    >;
};

export type ServiceProfessionalCreateManyProfessionalInputEnvelope = {
    data:
        | Prisma.ServiceProfessionalCreateManyProfessionalInput
        | Prisma.ServiceProfessionalCreateManyProfessionalInput[];
    skipDuplicates?: boolean;
};

export type ServiceProfessionalUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateWithoutProfessionalInput,
        Prisma.ServiceProfessionalUncheckedUpdateWithoutProfessionalInput
    >;
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateWithoutProfessionalInput,
        Prisma.ServiceProfessionalUncheckedCreateWithoutProfessionalInput
    >;
};

export type ServiceProfessionalUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateWithoutProfessionalInput,
        Prisma.ServiceProfessionalUncheckedUpdateWithoutProfessionalInput
    >;
};

export type ServiceProfessionalUpdateManyWithWhereWithoutProfessionalInput = {
    where: Prisma.ServiceProfessionalScalarWhereInput;
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateManyMutationInput,
        Prisma.ServiceProfessionalUncheckedUpdateManyWithoutProfessionalInput
    >;
};

export type ServiceProfessionalCreateWithoutServiceInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    professional: Prisma.ProfessionalCreateNestedOneWithoutServicesInput;
    company: Prisma.CompanyCreateNestedOneWithoutServiceProfessionalsInput;
};

export type ServiceProfessionalUncheckedCreateWithoutServiceInput = {
    id?: string;
    companyId: string;
    professionalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalCreateOrConnectWithoutServiceInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateWithoutServiceInput,
        Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput
    >;
};

export type ServiceProfessionalCreateManyServiceInputEnvelope = {
    data:
        | Prisma.ServiceProfessionalCreateManyServiceInput
        | Prisma.ServiceProfessionalCreateManyServiceInput[];
    skipDuplicates?: boolean;
};

export type ServiceProfessionalUpsertWithWhereUniqueWithoutServiceInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateWithoutServiceInput,
        Prisma.ServiceProfessionalUncheckedUpdateWithoutServiceInput
    >;
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateWithoutServiceInput,
        Prisma.ServiceProfessionalUncheckedCreateWithoutServiceInput
    >;
};

export type ServiceProfessionalUpdateWithWhereUniqueWithoutServiceInput = {
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateWithoutServiceInput,
        Prisma.ServiceProfessionalUncheckedUpdateWithoutServiceInput
    >;
};

export type ServiceProfessionalUpdateManyWithWhereWithoutServiceInput = {
    where: Prisma.ServiceProfessionalScalarWhereInput;
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateManyMutationInput,
        Prisma.ServiceProfessionalUncheckedUpdateManyWithoutServiceInput
    >;
};

export type ServiceProfessionalCreateManyCompanyInput = {
    id?: string;
    serviceId: string;
    professionalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalUpdateWithoutCompanyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    professional?: Prisma.ProfessionalUpdateOneRequiredWithoutServicesNestedInput;
    service?: Prisma.ServiceUpdateOneRequiredWithoutProfessionalsNestedInput;
};

export type ServiceProfessionalUncheckedUpdateWithoutCompanyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    serviceId?: Prisma.StringFieldUpdateOperationsInput | string;
    professionalId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalUncheckedUpdateManyWithoutCompanyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    serviceId?: Prisma.StringFieldUpdateOperationsInput | string;
    professionalId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalCreateManyProfessionalInput = {
    id?: string;
    companyId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalUpdateWithoutProfessionalInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    company?: Prisma.CompanyUpdateOneRequiredWithoutServiceProfessionalsNestedInput;
    service?: Prisma.ServiceUpdateOneRequiredWithoutProfessionalsNestedInput;
};

export type ServiceProfessionalUncheckedUpdateWithoutProfessionalInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    serviceId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalUncheckedUpdateManyWithoutProfessionalInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    serviceId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalCreateManyServiceInput = {
    id?: string;
    companyId: string;
    professionalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ServiceProfessionalUpdateWithoutServiceInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    professional?: Prisma.ProfessionalUpdateOneRequiredWithoutServicesNestedInput;
    company?: Prisma.CompanyUpdateOneRequiredWithoutServiceProfessionalsNestedInput;
};

export type ServiceProfessionalUncheckedUpdateWithoutServiceInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    professionalId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalUncheckedUpdateManyWithoutServiceInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    professionalId?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ServiceProfessionalSelect<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        companyId?: boolean;
        serviceId?: boolean;
        professionalId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        professional?: boolean | Prisma.ProfessionalDefaultArgs<ExtArgs>;
        company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
        service?: boolean | Prisma.ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceProfessional']
>;

export type ServiceProfessionalSelectCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        companyId?: boolean;
        serviceId?: boolean;
        professionalId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        professional?: boolean | Prisma.ProfessionalDefaultArgs<ExtArgs>;
        company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
        service?: boolean | Prisma.ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceProfessional']
>;

export type ServiceProfessionalSelectUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        companyId?: boolean;
        serviceId?: boolean;
        professionalId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        professional?: boolean | Prisma.ProfessionalDefaultArgs<ExtArgs>;
        company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
        service?: boolean | Prisma.ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceProfessional']
>;

export type ServiceProfessionalSelectScalar = {
    id?: boolean;
    companyId?: boolean;
    serviceId?: boolean;
    professionalId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};

export type ServiceProfessionalOmit<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
    | 'id'
    | 'companyId'
    | 'serviceId'
    | 'professionalId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['serviceProfessional']
>;
export type ServiceProfessionalInclude<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    professional?: boolean | Prisma.ProfessionalDefaultArgs<ExtArgs>;
    company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
    service?: boolean | Prisma.ServiceDefaultArgs<ExtArgs>;
};
export type ServiceProfessionalIncludeCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    professional?: boolean | Prisma.ProfessionalDefaultArgs<ExtArgs>;
    company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
    service?: boolean | Prisma.ServiceDefaultArgs<ExtArgs>;
};
export type ServiceProfessionalIncludeUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    professional?: boolean | Prisma.ProfessionalDefaultArgs<ExtArgs>;
    company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
    service?: boolean | Prisma.ServiceDefaultArgs<ExtArgs>;
};

export type $ServiceProfessionalPayload<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    name: 'ServiceProfessional';
    objects: {
        professional: Prisma.$ProfessionalPayload<ExtArgs>;
        company: Prisma.$CompanyPayload<ExtArgs>;
        service: Prisma.$ServicePayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            id: string;
            companyId: string;
            serviceId: string;
            professionalId: string;
            createdAt: Date;
            updatedAt: Date;
        },
        ExtArgs['result']['serviceProfessional']
    >;
    composites: {};
};

export type ServiceProfessionalGetPayload<
    S extends boolean | null | undefined | ServiceProfessionalDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$ServiceProfessionalPayload, S>;

export type ServiceProfessionalCountArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = Omit<
    ServiceProfessionalFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
> & {
    select?: ServiceProfessionalCountAggregateInputType | true;
};

export interface ServiceProfessionalDelegate<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> {
    [K: symbol]: {
        types: Prisma.TypeMap<ExtArgs>['model']['ServiceProfessional'];
        meta: { name: 'ServiceProfessional' };
    };
    /**
     * Find zero or one ServiceProfessional that matches the filter.
     * @param {ServiceProfessionalFindUniqueArgs} args - Arguments to find a ServiceProfessional
     * @example
     * // Get one ServiceProfessional
     * const serviceProfessional = await prisma.serviceProfessional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceProfessionalFindUniqueArgs>(
        args: Prisma.SelectSubset<T, ServiceProfessionalFindUniqueArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find one ServiceProfessional that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceProfessionalFindUniqueOrThrowArgs} args - Arguments to find a ServiceProfessional
     * @example
     * // Get one ServiceProfessional
     * const serviceProfessional = await prisma.serviceProfessional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceProfessionalFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<
            T,
            ServiceProfessionalFindUniqueOrThrowArgs<ExtArgs>
        >
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first ServiceProfessional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalFindFirstArgs} args - Arguments to find a ServiceProfessional
     * @example
     * // Get one ServiceProfessional
     * const serviceProfessional = await prisma.serviceProfessional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceProfessionalFindFirstArgs>(
        args?: Prisma.SelectSubset<T, ServiceProfessionalFindFirstArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first ServiceProfessional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalFindFirstOrThrowArgs} args - Arguments to find a ServiceProfessional
     * @example
     * // Get one ServiceProfessional
     * const serviceProfessional = await prisma.serviceProfessional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceProfessionalFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<
            T,
            ServiceProfessionalFindFirstOrThrowArgs<ExtArgs>
        >
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find zero or more ServiceProfessionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceProfessionals
     * const serviceProfessionals = await prisma.serviceProfessional.findMany()
     *
     * // Get first 10 ServiceProfessionals
     * const serviceProfessionals = await prisma.serviceProfessional.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceProfessionalWithIdOnly = await prisma.serviceProfessional.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceProfessionalFindManyArgs>(
        args?: Prisma.SelectSubset<T, ServiceProfessionalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'findMany',
            GlobalOmitOptions
        >
    >;

    /**
     * Create a ServiceProfessional.
     * @param {ServiceProfessionalCreateArgs} args - Arguments to create a ServiceProfessional.
     * @example
     * // Create one ServiceProfessional
     * const ServiceProfessional = await prisma.serviceProfessional.create({
     *   data: {
     *     // ... data to create a ServiceProfessional
     *   }
     * })
     *
     */
    create<T extends ServiceProfessionalCreateArgs>(
        args: Prisma.SelectSubset<T, ServiceProfessionalCreateArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'create',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Create many ServiceProfessionals.
     * @param {ServiceProfessionalCreateManyArgs} args - Arguments to create many ServiceProfessionals.
     * @example
     * // Create many ServiceProfessionals
     * const serviceProfessional = await prisma.serviceProfessional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceProfessionalCreateManyArgs>(
        args?: Prisma.SelectSubset<
            T,
            ServiceProfessionalCreateManyArgs<ExtArgs>
        >
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Create many ServiceProfessionals and returns the data saved in the database.
     * @param {ServiceProfessionalCreateManyAndReturnArgs} args - Arguments to create many ServiceProfessionals.
     * @example
     * // Create many ServiceProfessionals
     * const serviceProfessional = await prisma.serviceProfessional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceProfessionals and only return the `id`
     * const serviceProfessionalWithIdOnly = await prisma.serviceProfessional.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceProfessionalCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<
            T,
            ServiceProfessionalCreateManyAndReturnArgs<ExtArgs>
        >
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
        >
    >;

    /**
     * Delete a ServiceProfessional.
     * @param {ServiceProfessionalDeleteArgs} args - Arguments to delete one ServiceProfessional.
     * @example
     * // Delete one ServiceProfessional
     * const ServiceProfessional = await prisma.serviceProfessional.delete({
     *   where: {
     *     // ... filter to delete one ServiceProfessional
     *   }
     * })
     *
     */
    delete<T extends ServiceProfessionalDeleteArgs>(
        args: Prisma.SelectSubset<T, ServiceProfessionalDeleteArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'delete',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Update one ServiceProfessional.
     * @param {ServiceProfessionalUpdateArgs} args - Arguments to update one ServiceProfessional.
     * @example
     * // Update one ServiceProfessional
     * const serviceProfessional = await prisma.serviceProfessional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceProfessionalUpdateArgs>(
        args: Prisma.SelectSubset<T, ServiceProfessionalUpdateArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'update',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Delete zero or more ServiceProfessionals.
     * @param {ServiceProfessionalDeleteManyArgs} args - Arguments to filter ServiceProfessionals to delete.
     * @example
     * // Delete a few ServiceProfessionals
     * const { count } = await prisma.serviceProfessional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceProfessionalDeleteManyArgs>(
        args?: Prisma.SelectSubset<
            T,
            ServiceProfessionalDeleteManyArgs<ExtArgs>
        >
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more ServiceProfessionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceProfessionals
     * const serviceProfessional = await prisma.serviceProfessional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceProfessionalUpdateManyArgs>(
        args: Prisma.SelectSubset<T, ServiceProfessionalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more ServiceProfessionals and returns the data updated in the database.
     * @param {ServiceProfessionalUpdateManyAndReturnArgs} args - Arguments to update many ServiceProfessionals.
     * @example
     * // Update many ServiceProfessionals
     * const serviceProfessional = await prisma.serviceProfessional.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ServiceProfessionals and only return the `id`
     * const serviceProfessionalWithIdOnly = await prisma.serviceProfessional.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceProfessionalUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<
            T,
            ServiceProfessionalUpdateManyAndReturnArgs<ExtArgs>
        >
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
        >
    >;

    /**
     * Create or update one ServiceProfessional.
     * @param {ServiceProfessionalUpsertArgs} args - Arguments to update or create a ServiceProfessional.
     * @example
     * // Update or create a ServiceProfessional
     * const serviceProfessional = await prisma.serviceProfessional.upsert({
     *   create: {
     *     // ... data to create a ServiceProfessional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceProfessional we want to update
     *   }
     * })
     */
    upsert<T extends ServiceProfessionalUpsertArgs>(
        args: Prisma.SelectSubset<T, ServiceProfessionalUpsertArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceProfessionalClient<
        runtime.Types.Result.GetResult<
            Prisma.$ServiceProfessionalPayload<ExtArgs>,
            T,
            'upsert',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Count the number of ServiceProfessionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalCountArgs} args - Arguments to filter ServiceProfessionals to count.
     * @example
     * // Count the number of ServiceProfessionals
     * const count = await prisma.serviceProfessional.count({
     *   where: {
     *     // ... the filter for the ServiceProfessionals we want to count
     *   }
     * })
     **/
    count<T extends ServiceProfessionalCountArgs>(
        args?: Prisma.Subset<T, ServiceProfessionalCountArgs>
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<
                      T['select'],
                      ServiceProfessionalCountAggregateOutputType
                  >
            : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceProfessional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceProfessionalAggregateArgs>(
        args: Prisma.Subset<T, ServiceProfessionalAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceProfessionalAggregateType<T>>;

    /**
     * Group by ServiceProfessional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProfessionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends ServiceProfessionalGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
            Prisma.Extends<'skip', Prisma.Keys<T>>,
            Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: ServiceProfessionalGroupByArgs['orderBy'] }
            : { orderBy?: ServiceProfessionalGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<
            Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
        >,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
              ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                          : [
                                Error,
                                'Field ',
                                P,
                                ` in "having" needs to be provided in "by"`,
                            ];
                }[HavingFields]
              : 'take' extends Prisma.Keys<T>
                ? 'orderBy' extends Prisma.Keys<T>
                    ? ByValid extends Prisma.True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                    : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Prisma.Keys<T>
                  ? 'orderBy' extends Prisma.Keys<T>
                      ? ByValid extends Prisma.True
                          ? {}
                          : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                            }[OrderFields]
                      : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends Prisma.True
                    ? {}
                    : {
                          [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
    >(
        args: Prisma.SubsetIntersection<
            T,
            ServiceProfessionalGroupByArgs,
            OrderByArg
        > &
            InputErrors
    ): {} extends InputErrors
        ? GetServiceProfessionalGroupByPayload<T>
        : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceProfessional model
     */
    readonly fields: ServiceProfessionalFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ServiceProfessional.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ServiceProfessionalClient<
    T,
    Null = never,
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    professional<T extends Prisma.ProfessionalDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.ProfessionalDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__ProfessionalClient<
        | runtime.Types.Result.GetResult<
              Prisma.$ProfessionalPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    company<T extends Prisma.CompanyDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.CompanyDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__CompanyClient<
        | runtime.Types.Result.GetResult<
              Prisma.$CompanyPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    service<T extends Prisma.ServiceDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.ServiceDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__ServiceClient<
        | runtime.Types.Result.GetResult<
              Prisma.$ServicePayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?:
            | ((value: T) => TResult1 | PromiseLike<TResult1>)
            | undefined
            | null,
        onrejected?:
            | ((reason: any) => TResult2 | PromiseLike<TResult2>)
            | undefined
            | null
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?:
            | ((reason: any) => TResult | PromiseLike<TResult>)
            | undefined
            | null
    ): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(
        onfinally?: (() => void) | undefined | null
    ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the ServiceProfessional model
 */
export interface ServiceProfessionalFieldRefs {
    readonly id: Prisma.FieldRef<'ServiceProfessional', 'String'>;
    readonly companyId: Prisma.FieldRef<'ServiceProfessional', 'String'>;
    readonly serviceId: Prisma.FieldRef<'ServiceProfessional', 'String'>;
    readonly professionalId: Prisma.FieldRef<'ServiceProfessional', 'String'>;
    readonly createdAt: Prisma.FieldRef<'ServiceProfessional', 'DateTime'>;
    readonly updatedAt: Prisma.FieldRef<'ServiceProfessional', 'DateTime'>;
}

// Custom InputTypes
/**
 * ServiceProfessional findUnique
 */
export type ServiceProfessionalFindUniqueArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceProfessional to fetch.
     */
    where: Prisma.ServiceProfessionalWhereUniqueInput;
};

/**
 * ServiceProfessional findUniqueOrThrow
 */
export type ServiceProfessionalFindUniqueOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceProfessional to fetch.
     */
    where: Prisma.ServiceProfessionalWhereUniqueInput;
};

/**
 * ServiceProfessional findFirst
 */
export type ServiceProfessionalFindFirstArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceProfessional to fetch.
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceProfessionals to fetch.
     */
    orderBy?:
        | Prisma.ServiceProfessionalOrderByWithRelationInput
        | Prisma.ServiceProfessionalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceProfessionals.
     */
    cursor?: Prisma.ServiceProfessionalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ServiceProfessionals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceProfessionals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceProfessionals.
     */
    distinct?:
        | Prisma.ServiceProfessionalScalarFieldEnum
        | Prisma.ServiceProfessionalScalarFieldEnum[];
};

/**
 * ServiceProfessional findFirstOrThrow
 */
export type ServiceProfessionalFindFirstOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceProfessional to fetch.
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceProfessionals to fetch.
     */
    orderBy?:
        | Prisma.ServiceProfessionalOrderByWithRelationInput
        | Prisma.ServiceProfessionalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceProfessionals.
     */
    cursor?: Prisma.ServiceProfessionalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ServiceProfessionals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceProfessionals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceProfessionals.
     */
    distinct?:
        | Prisma.ServiceProfessionalScalarFieldEnum
        | Prisma.ServiceProfessionalScalarFieldEnum[];
};

/**
 * ServiceProfessional findMany
 */
export type ServiceProfessionalFindManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceProfessionals to fetch.
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceProfessionals to fetch.
     */
    orderBy?:
        | Prisma.ServiceProfessionalOrderByWithRelationInput
        | Prisma.ServiceProfessionalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceProfessionals.
     */
    cursor?: Prisma.ServiceProfessionalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ServiceProfessionals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceProfessionals.
     */
    skip?: number;
    distinct?:
        | Prisma.ServiceProfessionalScalarFieldEnum
        | Prisma.ServiceProfessionalScalarFieldEnum[];
};

/**
 * ServiceProfessional create
 */
export type ServiceProfessionalCreateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceProfessional.
     */
    data: Prisma.XOR<
        Prisma.ServiceProfessionalCreateInput,
        Prisma.ServiceProfessionalUncheckedCreateInput
    >;
};

/**
 * ServiceProfessional createMany
 */
export type ServiceProfessionalCreateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to create many ServiceProfessionals.
     */
    data:
        | Prisma.ServiceProfessionalCreateManyInput
        | Prisma.ServiceProfessionalCreateManyInput[];
    skipDuplicates?: boolean;
};

/**
 * ServiceProfessional createManyAndReturn
 */
export type ServiceProfessionalCreateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * The data used to create many ServiceProfessionals.
     */
    data:
        | Prisma.ServiceProfessionalCreateManyInput
        | Prisma.ServiceProfessionalCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * ServiceProfessional update
 */
export type ServiceProfessionalUpdateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceProfessional.
     */
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateInput,
        Prisma.ServiceProfessionalUncheckedUpdateInput
    >;
    /**
     * Choose, which ServiceProfessional to update.
     */
    where: Prisma.ServiceProfessionalWhereUniqueInput;
};

/**
 * ServiceProfessional updateMany
 */
export type ServiceProfessionalUpdateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to update ServiceProfessionals.
     */
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateManyMutationInput,
        Prisma.ServiceProfessionalUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceProfessionals to update
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * Limit how many ServiceProfessionals to update.
     */
    limit?: number;
};

/**
 * ServiceProfessional updateManyAndReturn
 */
export type ServiceProfessionalUpdateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * The data used to update ServiceProfessionals.
     */
    data: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateManyMutationInput,
        Prisma.ServiceProfessionalUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceProfessionals to update
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * Limit how many ServiceProfessionals to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * ServiceProfessional upsert
 */
export type ServiceProfessionalUpsertArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceProfessional to update in case it exists.
     */
    where: Prisma.ServiceProfessionalWhereUniqueInput;
    /**
     * In case the ServiceProfessional found by the `where` argument doesn't exist, create a new ServiceProfessional with this data.
     */
    create: Prisma.XOR<
        Prisma.ServiceProfessionalCreateInput,
        Prisma.ServiceProfessionalUncheckedCreateInput
    >;
    /**
     * In case the ServiceProfessional was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<
        Prisma.ServiceProfessionalUpdateInput,
        Prisma.ServiceProfessionalUncheckedUpdateInput
    >;
};

/**
 * ServiceProfessional delete
 */
export type ServiceProfessionalDeleteArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
    /**
     * Filter which ServiceProfessional to delete.
     */
    where: Prisma.ServiceProfessionalWhereUniqueInput;
};

/**
 * ServiceProfessional deleteMany
 */
export type ServiceProfessionalDeleteManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which ServiceProfessionals to delete
     */
    where?: Prisma.ServiceProfessionalWhereInput;
    /**
     * Limit how many ServiceProfessionals to delete.
     */
    limit?: number;
};

/**
 * ServiceProfessional without action
 */
export type ServiceProfessionalDefaultArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ServiceProfessional
     */
    select?: Prisma.ServiceProfessionalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ServiceProfessional
     */
    omit?: Prisma.ServiceProfessionalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ServiceProfessionalInclude<ExtArgs> | null;
};
