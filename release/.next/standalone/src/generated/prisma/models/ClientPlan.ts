/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * This file exports the `ClientPlan` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/library';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model ClientPlan
 *
 */
export type ClientPlanModel =
    runtime.Types.Result.DefaultSelection<Prisma.$ClientPlanPayload>;

export type AggregateClientPlan = {
    _count: ClientPlanCountAggregateOutputType | null;
    _avg: ClientPlanAvgAggregateOutputType | null;
    _sum: ClientPlanSumAggregateOutputType | null;
    _min: ClientPlanMinAggregateOutputType | null;
    _max: ClientPlanMaxAggregateOutputType | null;
};

export type ClientPlanAvgAggregateOutputType = {
    usedBookings: number | null;
};

export type ClientPlanSumAggregateOutputType = {
    usedBookings: number | null;
};

export type ClientPlanMinAggregateOutputType = {
    id: string | null;
    companyId: string | null;
    clientId: string | null;
    planId: string | null;
    startDate: Date | null;
    endDate: Date | null;
    usedBookings: number | null;
    status: $Enums.ClientPlanStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};

export type ClientPlanMaxAggregateOutputType = {
    id: string | null;
    companyId: string | null;
    clientId: string | null;
    planId: string | null;
    startDate: Date | null;
    endDate: Date | null;
    usedBookings: number | null;
    status: $Enums.ClientPlanStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};

export type ClientPlanCountAggregateOutputType = {
    id: number;
    companyId: number;
    clientId: number;
    planId: number;
    startDate: number;
    endDate: number;
    usedBookings: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};

export type ClientPlanAvgAggregateInputType = {
    usedBookings?: true;
};

export type ClientPlanSumAggregateInputType = {
    usedBookings?: true;
};

export type ClientPlanMinAggregateInputType = {
    id?: true;
    companyId?: true;
    clientId?: true;
    planId?: true;
    startDate?: true;
    endDate?: true;
    usedBookings?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
};

export type ClientPlanMaxAggregateInputType = {
    id?: true;
    companyId?: true;
    clientId?: true;
    planId?: true;
    startDate?: true;
    endDate?: true;
    usedBookings?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
};

export type ClientPlanCountAggregateInputType = {
    id?: true;
    companyId?: true;
    clientId?: true;
    planId?: true;
    startDate?: true;
    endDate?: true;
    usedBookings?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};

export type ClientPlanAggregateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which ClientPlan to aggregate.
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?:
        | Prisma.ClientPlanOrderByWithRelationInput
        | Prisma.ClientPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.ClientPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ClientPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientPlans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ClientPlans
     **/
    _count?: true | ClientPlanCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ClientPlanAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ClientPlanSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClientPlanMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClientPlanMaxAggregateInputType;
};

export type GetClientPlanAggregateType<T extends ClientPlanAggregateArgs> = {
    [P in keyof T & keyof AggregateClientPlan]: P extends '_count' | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateClientPlan[P]>
        : Prisma.GetScalarType<T[P], AggregateClientPlan[P]>;
};

export type ClientPlanGroupByArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.ClientPlanWhereInput;
    orderBy?:
        | Prisma.ClientPlanOrderByWithAggregationInput
        | Prisma.ClientPlanOrderByWithAggregationInput[];
    by: Prisma.ClientPlanScalarFieldEnum[] | Prisma.ClientPlanScalarFieldEnum;
    having?: Prisma.ClientPlanScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClientPlanCountAggregateInputType | true;
    _avg?: ClientPlanAvgAggregateInputType;
    _sum?: ClientPlanSumAggregateInputType;
    _min?: ClientPlanMinAggregateInputType;
    _max?: ClientPlanMaxAggregateInputType;
};

export type ClientPlanGroupByOutputType = {
    id: string;
    companyId: string;
    clientId: string;
    planId: string;
    startDate: Date;
    endDate: Date;
    usedBookings: number;
    status: $Enums.ClientPlanStatus;
    createdAt: Date;
    updatedAt: Date;
    _count: ClientPlanCountAggregateOutputType | null;
    _avg: ClientPlanAvgAggregateOutputType | null;
    _sum: ClientPlanSumAggregateOutputType | null;
    _min: ClientPlanMinAggregateOutputType | null;
    _max: ClientPlanMaxAggregateOutputType | null;
};

type GetClientPlanGroupByPayload<T extends ClientPlanGroupByArgs> =
    Prisma.PrismaPromise<
        Array<
            Prisma.PickEnumerable<ClientPlanGroupByOutputType, T['by']> & {
                [P in keyof T &
                    keyof ClientPlanGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : Prisma.GetScalarType<
                              T[P],
                              ClientPlanGroupByOutputType[P]
                          >
                    : Prisma.GetScalarType<
                          T[P],
                          ClientPlanGroupByOutputType[P]
                      >;
            }
        >
    >;

export type ClientPlanWhereInput = {
    AND?: Prisma.ClientPlanWhereInput | Prisma.ClientPlanWhereInput[];
    OR?: Prisma.ClientPlanWhereInput[];
    NOT?: Prisma.ClientPlanWhereInput | Prisma.ClientPlanWhereInput[];
    id?: Prisma.StringFilter<'ClientPlan'> | string;
    companyId?: Prisma.StringFilter<'ClientPlan'> | string;
    clientId?: Prisma.StringFilter<'ClientPlan'> | string;
    planId?: Prisma.StringFilter<'ClientPlan'> | string;
    startDate?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    endDate?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    usedBookings?: Prisma.IntFilter<'ClientPlan'> | number;
    status?:
        | Prisma.EnumClientPlanStatusFilter<'ClientPlan'>
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    appointments?: Prisma.AppointmentListRelationFilter;
    client?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
    company?: Prisma.XOR<
        Prisma.CompanyScalarRelationFilter,
        Prisma.CompanyWhereInput
    >;
    plan?: Prisma.XOR<Prisma.PlanScalarRelationFilter, Prisma.PlanWhereInput>;
};

export type ClientPlanOrderByWithRelationInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    clientId?: Prisma.SortOrder;
    planId?: Prisma.SortOrder;
    startDate?: Prisma.SortOrder;
    endDate?: Prisma.SortOrder;
    usedBookings?: Prisma.SortOrder;
    status?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    appointments?: Prisma.AppointmentOrderByRelationAggregateInput;
    client?: Prisma.UserOrderByWithRelationInput;
    company?: Prisma.CompanyOrderByWithRelationInput;
    plan?: Prisma.PlanOrderByWithRelationInput;
};

export type ClientPlanWhereUniqueInput = Prisma.AtLeast<
    {
        id?: string;
        AND?: Prisma.ClientPlanWhereInput | Prisma.ClientPlanWhereInput[];
        OR?: Prisma.ClientPlanWhereInput[];
        NOT?: Prisma.ClientPlanWhereInput | Prisma.ClientPlanWhereInput[];
        companyId?: Prisma.StringFilter<'ClientPlan'> | string;
        clientId?: Prisma.StringFilter<'ClientPlan'> | string;
        planId?: Prisma.StringFilter<'ClientPlan'> | string;
        startDate?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
        endDate?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
        usedBookings?: Prisma.IntFilter<'ClientPlan'> | number;
        status?:
            | Prisma.EnumClientPlanStatusFilter<'ClientPlan'>
            | $Enums.ClientPlanStatus;
        createdAt?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
        updatedAt?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
        appointments?: Prisma.AppointmentListRelationFilter;
        client?: Prisma.XOR<
            Prisma.UserScalarRelationFilter,
            Prisma.UserWhereInput
        >;
        company?: Prisma.XOR<
            Prisma.CompanyScalarRelationFilter,
            Prisma.CompanyWhereInput
        >;
        plan?: Prisma.XOR<
            Prisma.PlanScalarRelationFilter,
            Prisma.PlanWhereInput
        >;
    },
    'id'
>;

export type ClientPlanOrderByWithAggregationInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    clientId?: Prisma.SortOrder;
    planId?: Prisma.SortOrder;
    startDate?: Prisma.SortOrder;
    endDate?: Prisma.SortOrder;
    usedBookings?: Prisma.SortOrder;
    status?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    _count?: Prisma.ClientPlanCountOrderByAggregateInput;
    _avg?: Prisma.ClientPlanAvgOrderByAggregateInput;
    _max?: Prisma.ClientPlanMaxOrderByAggregateInput;
    _min?: Prisma.ClientPlanMinOrderByAggregateInput;
    _sum?: Prisma.ClientPlanSumOrderByAggregateInput;
};

export type ClientPlanScalarWhereWithAggregatesInput = {
    AND?:
        | Prisma.ClientPlanScalarWhereWithAggregatesInput
        | Prisma.ClientPlanScalarWhereWithAggregatesInput[];
    OR?: Prisma.ClientPlanScalarWhereWithAggregatesInput[];
    NOT?:
        | Prisma.ClientPlanScalarWhereWithAggregatesInput
        | Prisma.ClientPlanScalarWhereWithAggregatesInput[];
    id?: Prisma.StringWithAggregatesFilter<'ClientPlan'> | string;
    companyId?: Prisma.StringWithAggregatesFilter<'ClientPlan'> | string;
    clientId?: Prisma.StringWithAggregatesFilter<'ClientPlan'> | string;
    planId?: Prisma.StringWithAggregatesFilter<'ClientPlan'> | string;
    startDate?:
        | Prisma.DateTimeWithAggregatesFilter<'ClientPlan'>
        | Date
        | string;
    endDate?: Prisma.DateTimeWithAggregatesFilter<'ClientPlan'> | Date | string;
    usedBookings?: Prisma.IntWithAggregatesFilter<'ClientPlan'> | number;
    status?:
        | Prisma.EnumClientPlanStatusWithAggregatesFilter<'ClientPlan'>
        | $Enums.ClientPlanStatus;
    createdAt?:
        | Prisma.DateTimeWithAggregatesFilter<'ClientPlan'>
        | Date
        | string;
    updatedAt?:
        | Prisma.DateTimeWithAggregatesFilter<'ClientPlan'>
        | Date
        | string;
};

export type ClientPlanCreateInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentCreateNestedManyWithoutClientPlanInput;
    client: Prisma.UserCreateNestedOneWithoutClientPlansInput;
    company: Prisma.CompanyCreateNestedOneWithoutClientPlansInput;
    plan: Prisma.PlanCreateNestedOneWithoutClientPlansInput;
};

export type ClientPlanUncheckedCreateInput = {
    id?: string;
    companyId: string;
    clientId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentUncheckedCreateNestedManyWithoutClientPlanInput;
};

export type ClientPlanUpdateInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUpdateManyWithoutClientPlanNestedInput;
    client?: Prisma.UserUpdateOneRequiredWithoutClientPlansNestedInput;
    company?: Prisma.CompanyUpdateOneRequiredWithoutClientPlansNestedInput;
    plan?: Prisma.PlanUpdateOneRequiredWithoutClientPlansNestedInput;
};

export type ClientPlanUncheckedUpdateInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUncheckedUpdateManyWithoutClientPlanNestedInput;
};

export type ClientPlanCreateManyInput = {
    id?: string;
    companyId: string;
    clientId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ClientPlanUpdateManyMutationInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ClientPlanUncheckedUpdateManyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ClientPlanListRelationFilter = {
    every?: Prisma.ClientPlanWhereInput;
    some?: Prisma.ClientPlanWhereInput;
    none?: Prisma.ClientPlanWhereInput;
};

export type ClientPlanOrderByRelationAggregateInput = {
    _count?: Prisma.SortOrder;
};

export type ClientPlanCountOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    clientId?: Prisma.SortOrder;
    planId?: Prisma.SortOrder;
    startDate?: Prisma.SortOrder;
    endDate?: Prisma.SortOrder;
    usedBookings?: Prisma.SortOrder;
    status?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type ClientPlanAvgOrderByAggregateInput = {
    usedBookings?: Prisma.SortOrder;
};

export type ClientPlanMaxOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    clientId?: Prisma.SortOrder;
    planId?: Prisma.SortOrder;
    startDate?: Prisma.SortOrder;
    endDate?: Prisma.SortOrder;
    usedBookings?: Prisma.SortOrder;
    status?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type ClientPlanMinOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    companyId?: Prisma.SortOrder;
    clientId?: Prisma.SortOrder;
    planId?: Prisma.SortOrder;
    startDate?: Prisma.SortOrder;
    endDate?: Prisma.SortOrder;
    usedBookings?: Prisma.SortOrder;
    status?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
};

export type ClientPlanSumOrderByAggregateInput = {
    usedBookings?: Prisma.SortOrder;
};

export type ClientPlanNullableScalarRelationFilter = {
    is?: Prisma.ClientPlanWhereInput | null;
    isNot?: Prisma.ClientPlanWhereInput | null;
};

export type ClientPlanCreateNestedManyWithoutCompanyInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutCompanyInput,
              Prisma.ClientPlanUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ClientPlanCreateWithoutCompanyInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput[];
    createMany?: Prisma.ClientPlanCreateManyCompanyInputEnvelope;
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
};

export type ClientPlanUncheckedCreateNestedManyWithoutCompanyInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutCompanyInput,
              Prisma.ClientPlanUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ClientPlanCreateWithoutCompanyInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput[];
    createMany?: Prisma.ClientPlanCreateManyCompanyInputEnvelope;
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
};

export type ClientPlanUpdateManyWithoutCompanyNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutCompanyInput,
              Prisma.ClientPlanUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ClientPlanCreateWithoutCompanyInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput[];
    upsert?:
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutCompanyInput
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: Prisma.ClientPlanCreateManyCompanyInputEnvelope;
    set?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    disconnect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    delete?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    update?:
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutCompanyInput
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
        | Prisma.ClientPlanUpdateManyWithWhereWithoutCompanyInput
        | Prisma.ClientPlanUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
};

export type ClientPlanUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutCompanyInput,
              Prisma.ClientPlanUncheckedCreateWithoutCompanyInput
          >
        | Prisma.ClientPlanCreateWithoutCompanyInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutCompanyInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput
        | Prisma.ClientPlanCreateOrConnectWithoutCompanyInput[];
    upsert?:
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutCompanyInput
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutCompanyInput[];
    createMany?: Prisma.ClientPlanCreateManyCompanyInputEnvelope;
    set?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    disconnect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    delete?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    update?:
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutCompanyInput
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutCompanyInput[];
    updateMany?:
        | Prisma.ClientPlanUpdateManyWithWhereWithoutCompanyInput
        | Prisma.ClientPlanUpdateManyWithWhereWithoutCompanyInput[];
    deleteMany?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
};

export type ClientPlanCreateNestedManyWithoutClientInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutClientInput,
              Prisma.ClientPlanUncheckedCreateWithoutClientInput
          >
        | Prisma.ClientPlanCreateWithoutClientInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput[];
    createMany?: Prisma.ClientPlanCreateManyClientInputEnvelope;
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
};

export type ClientPlanUncheckedCreateNestedManyWithoutClientInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutClientInput,
              Prisma.ClientPlanUncheckedCreateWithoutClientInput
          >
        | Prisma.ClientPlanCreateWithoutClientInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput[];
    createMany?: Prisma.ClientPlanCreateManyClientInputEnvelope;
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
};

export type ClientPlanUpdateManyWithoutClientNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutClientInput,
              Prisma.ClientPlanUncheckedCreateWithoutClientInput
          >
        | Prisma.ClientPlanCreateWithoutClientInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput[];
    upsert?:
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutClientInput
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: Prisma.ClientPlanCreateManyClientInputEnvelope;
    set?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    disconnect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    delete?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    update?:
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutClientInput
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
        | Prisma.ClientPlanUpdateManyWithWhereWithoutClientInput
        | Prisma.ClientPlanUpdateManyWithWhereWithoutClientInput[];
    deleteMany?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
};

export type ClientPlanUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutClientInput,
              Prisma.ClientPlanUncheckedCreateWithoutClientInput
          >
        | Prisma.ClientPlanCreateWithoutClientInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput
        | Prisma.ClientPlanCreateOrConnectWithoutClientInput[];
    upsert?:
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutClientInput
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: Prisma.ClientPlanCreateManyClientInputEnvelope;
    set?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    disconnect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    delete?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    update?:
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutClientInput
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
        | Prisma.ClientPlanUpdateManyWithWhereWithoutClientInput
        | Prisma.ClientPlanUpdateManyWithWhereWithoutClientInput[];
    deleteMany?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
};

export type ClientPlanCreateNestedManyWithoutPlanInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutPlanInput,
              Prisma.ClientPlanUncheckedCreateWithoutPlanInput
          >
        | Prisma.ClientPlanCreateWithoutPlanInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput[];
    createMany?: Prisma.ClientPlanCreateManyPlanInputEnvelope;
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
};

export type ClientPlanUncheckedCreateNestedManyWithoutPlanInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutPlanInput,
              Prisma.ClientPlanUncheckedCreateWithoutPlanInput
          >
        | Prisma.ClientPlanCreateWithoutPlanInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput[];
    createMany?: Prisma.ClientPlanCreateManyPlanInputEnvelope;
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
};

export type ClientPlanUpdateManyWithoutPlanNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutPlanInput,
              Prisma.ClientPlanUncheckedCreateWithoutPlanInput
          >
        | Prisma.ClientPlanCreateWithoutPlanInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput[];
    upsert?:
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutPlanInput
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutPlanInput[];
    createMany?: Prisma.ClientPlanCreateManyPlanInputEnvelope;
    set?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    disconnect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    delete?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    update?:
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutPlanInput
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutPlanInput[];
    updateMany?:
        | Prisma.ClientPlanUpdateManyWithWhereWithoutPlanInput
        | Prisma.ClientPlanUpdateManyWithWhereWithoutPlanInput[];
    deleteMany?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
};

export type ClientPlanUncheckedUpdateManyWithoutPlanNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.ClientPlanCreateWithoutPlanInput,
              Prisma.ClientPlanUncheckedCreateWithoutPlanInput
          >
        | Prisma.ClientPlanCreateWithoutPlanInput[]
        | Prisma.ClientPlanUncheckedCreateWithoutPlanInput[];
    connectOrCreate?:
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput
        | Prisma.ClientPlanCreateOrConnectWithoutPlanInput[];
    upsert?:
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutPlanInput
        | Prisma.ClientPlanUpsertWithWhereUniqueWithoutPlanInput[];
    createMany?: Prisma.ClientPlanCreateManyPlanInputEnvelope;
    set?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    disconnect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    delete?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    connect?:
        | Prisma.ClientPlanWhereUniqueInput
        | Prisma.ClientPlanWhereUniqueInput[];
    update?:
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutPlanInput
        | Prisma.ClientPlanUpdateWithWhereUniqueWithoutPlanInput[];
    updateMany?:
        | Prisma.ClientPlanUpdateManyWithWhereWithoutPlanInput
        | Prisma.ClientPlanUpdateManyWithWhereWithoutPlanInput[];
    deleteMany?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
};

export type EnumClientPlanStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClientPlanStatus;
};

export type ClientPlanCreateNestedOneWithoutAppointmentsInput = {
    create?: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutAppointmentsInput,
        Prisma.ClientPlanUncheckedCreateWithoutAppointmentsInput
    >;
    connectOrCreate?: Prisma.ClientPlanCreateOrConnectWithoutAppointmentsInput;
    connect?: Prisma.ClientPlanWhereUniqueInput;
};

export type ClientPlanUpdateOneWithoutAppointmentsNestedInput = {
    create?: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutAppointmentsInput,
        Prisma.ClientPlanUncheckedCreateWithoutAppointmentsInput
    >;
    connectOrCreate?: Prisma.ClientPlanCreateOrConnectWithoutAppointmentsInput;
    upsert?: Prisma.ClientPlanUpsertWithoutAppointmentsInput;
    disconnect?: Prisma.ClientPlanWhereInput | boolean;
    delete?: Prisma.ClientPlanWhereInput | boolean;
    connect?: Prisma.ClientPlanWhereUniqueInput;
    update?: Prisma.XOR<
        Prisma.XOR<
            Prisma.ClientPlanUpdateToOneWithWhereWithoutAppointmentsInput,
            Prisma.ClientPlanUpdateWithoutAppointmentsInput
        >,
        Prisma.ClientPlanUncheckedUpdateWithoutAppointmentsInput
    >;
};

export type ClientPlanCreateWithoutCompanyInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentCreateNestedManyWithoutClientPlanInput;
    client: Prisma.UserCreateNestedOneWithoutClientPlansInput;
    plan: Prisma.PlanCreateNestedOneWithoutClientPlansInput;
};

export type ClientPlanUncheckedCreateWithoutCompanyInput = {
    id?: string;
    clientId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentUncheckedCreateNestedManyWithoutClientPlanInput;
};

export type ClientPlanCreateOrConnectWithoutCompanyInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutCompanyInput,
        Prisma.ClientPlanUncheckedCreateWithoutCompanyInput
    >;
};

export type ClientPlanCreateManyCompanyInputEnvelope = {
    data:
        | Prisma.ClientPlanCreateManyCompanyInput
        | Prisma.ClientPlanCreateManyCompanyInput[];
    skipDuplicates?: boolean;
};

export type ClientPlanUpsertWithWhereUniqueWithoutCompanyInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutCompanyInput,
        Prisma.ClientPlanUncheckedUpdateWithoutCompanyInput
    >;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutCompanyInput,
        Prisma.ClientPlanUncheckedCreateWithoutCompanyInput
    >;
};

export type ClientPlanUpdateWithWhereUniqueWithoutCompanyInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutCompanyInput,
        Prisma.ClientPlanUncheckedUpdateWithoutCompanyInput
    >;
};

export type ClientPlanUpdateManyWithWhereWithoutCompanyInput = {
    where: Prisma.ClientPlanScalarWhereInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateManyMutationInput,
        Prisma.ClientPlanUncheckedUpdateManyWithoutCompanyInput
    >;
};

export type ClientPlanScalarWhereInput = {
    AND?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
    OR?: Prisma.ClientPlanScalarWhereInput[];
    NOT?:
        | Prisma.ClientPlanScalarWhereInput
        | Prisma.ClientPlanScalarWhereInput[];
    id?: Prisma.StringFilter<'ClientPlan'> | string;
    companyId?: Prisma.StringFilter<'ClientPlan'> | string;
    clientId?: Prisma.StringFilter<'ClientPlan'> | string;
    planId?: Prisma.StringFilter<'ClientPlan'> | string;
    startDate?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    endDate?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    usedBookings?: Prisma.IntFilter<'ClientPlan'> | number;
    status?:
        | Prisma.EnumClientPlanStatusFilter<'ClientPlan'>
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'ClientPlan'> | Date | string;
};

export type ClientPlanCreateWithoutClientInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentCreateNestedManyWithoutClientPlanInput;
    company: Prisma.CompanyCreateNestedOneWithoutClientPlansInput;
    plan: Prisma.PlanCreateNestedOneWithoutClientPlansInput;
};

export type ClientPlanUncheckedCreateWithoutClientInput = {
    id?: string;
    companyId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentUncheckedCreateNestedManyWithoutClientPlanInput;
};

export type ClientPlanCreateOrConnectWithoutClientInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutClientInput,
        Prisma.ClientPlanUncheckedCreateWithoutClientInput
    >;
};

export type ClientPlanCreateManyClientInputEnvelope = {
    data:
        | Prisma.ClientPlanCreateManyClientInput
        | Prisma.ClientPlanCreateManyClientInput[];
    skipDuplicates?: boolean;
};

export type ClientPlanUpsertWithWhereUniqueWithoutClientInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutClientInput,
        Prisma.ClientPlanUncheckedUpdateWithoutClientInput
    >;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutClientInput,
        Prisma.ClientPlanUncheckedCreateWithoutClientInput
    >;
};

export type ClientPlanUpdateWithWhereUniqueWithoutClientInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutClientInput,
        Prisma.ClientPlanUncheckedUpdateWithoutClientInput
    >;
};

export type ClientPlanUpdateManyWithWhereWithoutClientInput = {
    where: Prisma.ClientPlanScalarWhereInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateManyMutationInput,
        Prisma.ClientPlanUncheckedUpdateManyWithoutClientInput
    >;
};

export type ClientPlanCreateWithoutPlanInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentCreateNestedManyWithoutClientPlanInput;
    client: Prisma.UserCreateNestedOneWithoutClientPlansInput;
    company: Prisma.CompanyCreateNestedOneWithoutClientPlansInput;
};

export type ClientPlanUncheckedCreateWithoutPlanInput = {
    id?: string;
    companyId: string;
    clientId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    appointments?: Prisma.AppointmentUncheckedCreateNestedManyWithoutClientPlanInput;
};

export type ClientPlanCreateOrConnectWithoutPlanInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutPlanInput,
        Prisma.ClientPlanUncheckedCreateWithoutPlanInput
    >;
};

export type ClientPlanCreateManyPlanInputEnvelope = {
    data:
        | Prisma.ClientPlanCreateManyPlanInput
        | Prisma.ClientPlanCreateManyPlanInput[];
    skipDuplicates?: boolean;
};

export type ClientPlanUpsertWithWhereUniqueWithoutPlanInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutPlanInput,
        Prisma.ClientPlanUncheckedUpdateWithoutPlanInput
    >;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutPlanInput,
        Prisma.ClientPlanUncheckedCreateWithoutPlanInput
    >;
};

export type ClientPlanUpdateWithWhereUniqueWithoutPlanInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutPlanInput,
        Prisma.ClientPlanUncheckedUpdateWithoutPlanInput
    >;
};

export type ClientPlanUpdateManyWithWhereWithoutPlanInput = {
    where: Prisma.ClientPlanScalarWhereInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateManyMutationInput,
        Prisma.ClientPlanUncheckedUpdateManyWithoutPlanInput
    >;
};

export type ClientPlanCreateWithoutAppointmentsInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    client: Prisma.UserCreateNestedOneWithoutClientPlansInput;
    company: Prisma.CompanyCreateNestedOneWithoutClientPlansInput;
    plan: Prisma.PlanCreateNestedOneWithoutClientPlansInput;
};

export type ClientPlanUncheckedCreateWithoutAppointmentsInput = {
    id?: string;
    companyId: string;
    clientId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ClientPlanCreateOrConnectWithoutAppointmentsInput = {
    where: Prisma.ClientPlanWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutAppointmentsInput,
        Prisma.ClientPlanUncheckedCreateWithoutAppointmentsInput
    >;
};

export type ClientPlanUpsertWithoutAppointmentsInput = {
    update: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutAppointmentsInput,
        Prisma.ClientPlanUncheckedUpdateWithoutAppointmentsInput
    >;
    create: Prisma.XOR<
        Prisma.ClientPlanCreateWithoutAppointmentsInput,
        Prisma.ClientPlanUncheckedCreateWithoutAppointmentsInput
    >;
    where?: Prisma.ClientPlanWhereInput;
};

export type ClientPlanUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: Prisma.ClientPlanWhereInput;
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateWithoutAppointmentsInput,
        Prisma.ClientPlanUncheckedUpdateWithoutAppointmentsInput
    >;
};

export type ClientPlanUpdateWithoutAppointmentsInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    client?: Prisma.UserUpdateOneRequiredWithoutClientPlansNestedInput;
    company?: Prisma.CompanyUpdateOneRequiredWithoutClientPlansNestedInput;
    plan?: Prisma.PlanUpdateOneRequiredWithoutClientPlansNestedInput;
};

export type ClientPlanUncheckedUpdateWithoutAppointmentsInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ClientPlanCreateManyCompanyInput = {
    id?: string;
    clientId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ClientPlanUpdateWithoutCompanyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUpdateManyWithoutClientPlanNestedInput;
    client?: Prisma.UserUpdateOneRequiredWithoutClientPlansNestedInput;
    plan?: Prisma.PlanUpdateOneRequiredWithoutClientPlansNestedInput;
};

export type ClientPlanUncheckedUpdateWithoutCompanyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUncheckedUpdateManyWithoutClientPlanNestedInput;
};

export type ClientPlanUncheckedUpdateManyWithoutCompanyInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ClientPlanCreateManyClientInput = {
    id?: string;
    companyId: string;
    planId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ClientPlanUpdateWithoutClientInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUpdateManyWithoutClientPlanNestedInput;
    company?: Prisma.CompanyUpdateOneRequiredWithoutClientPlansNestedInput;
    plan?: Prisma.PlanUpdateOneRequiredWithoutClientPlansNestedInput;
};

export type ClientPlanUncheckedUpdateWithoutClientInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUncheckedUpdateManyWithoutClientPlanNestedInput;
};

export type ClientPlanUncheckedUpdateManyWithoutClientInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    planId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ClientPlanCreateManyPlanInput = {
    id?: string;
    companyId: string;
    clientId: string;
    startDate: Date | string;
    endDate: Date | string;
    usedBookings?: number;
    status?: $Enums.ClientPlanStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};

export type ClientPlanUpdateWithoutPlanInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUpdateManyWithoutClientPlanNestedInput;
    client?: Prisma.UserUpdateOneRequiredWithoutClientPlansNestedInput;
    company?: Prisma.CompanyUpdateOneRequiredWithoutClientPlansNestedInput;
};

export type ClientPlanUncheckedUpdateWithoutPlanInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    appointments?: Prisma.AppointmentUncheckedUpdateManyWithoutClientPlanNestedInput;
};

export type ClientPlanUncheckedUpdateManyWithoutPlanInput = {
    id?: Prisma.StringFieldUpdateOperationsInput | string;
    companyId?: Prisma.StringFieldUpdateOperationsInput | string;
    clientId?: Prisma.StringFieldUpdateOperationsInput | string;
    startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    usedBookings?: Prisma.IntFieldUpdateOperationsInput | number;
    status?:
        | Prisma.EnumClientPlanStatusFieldUpdateOperationsInput
        | $Enums.ClientPlanStatus;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

/**
 * Count Type ClientPlanCountOutputType
 */

export type ClientPlanCountOutputType = {
    appointments: number;
};

export type ClientPlanCountOutputTypeSelect<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    appointments?: boolean | ClientPlanCountOutputTypeCountAppointmentsArgs;
};

/**
 * ClientPlanCountOutputType without action
 */
export type ClientPlanCountOutputTypeDefaultArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlanCountOutputType
     */
    select?: Prisma.ClientPlanCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * ClientPlanCountOutputType without action
 */
export type ClientPlanCountOutputTypeCountAppointmentsArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.AppointmentWhereInput;
};

export type ClientPlanSelect<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        companyId?: boolean;
        clientId?: boolean;
        planId?: boolean;
        startDate?: boolean;
        endDate?: boolean;
        usedBookings?: boolean;
        status?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        appointments?: boolean | Prisma.ClientPlan$appointmentsArgs<ExtArgs>;
        client?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
        company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
        plan?: boolean | Prisma.PlanDefaultArgs<ExtArgs>;
        _count?: boolean | Prisma.ClientPlanCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['clientPlan']
>;

export type ClientPlanSelectCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        companyId?: boolean;
        clientId?: boolean;
        planId?: boolean;
        startDate?: boolean;
        endDate?: boolean;
        usedBookings?: boolean;
        status?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        client?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
        company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
        plan?: boolean | Prisma.PlanDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['clientPlan']
>;

export type ClientPlanSelectUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        companyId?: boolean;
        clientId?: boolean;
        planId?: boolean;
        startDate?: boolean;
        endDate?: boolean;
        usedBookings?: boolean;
        status?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        client?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
        company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
        plan?: boolean | Prisma.PlanDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['clientPlan']
>;

export type ClientPlanSelectScalar = {
    id?: boolean;
    companyId?: boolean;
    clientId?: boolean;
    planId?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    usedBookings?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};

export type ClientPlanOmit<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
    | 'id'
    | 'companyId'
    | 'clientId'
    | 'planId'
    | 'startDate'
    | 'endDate'
    | 'usedBookings'
    | 'status'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['clientPlan']
>;
export type ClientPlanInclude<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    appointments?: boolean | Prisma.ClientPlan$appointmentsArgs<ExtArgs>;
    client?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
    plan?: boolean | Prisma.PlanDefaultArgs<ExtArgs>;
    _count?: boolean | Prisma.ClientPlanCountOutputTypeDefaultArgs<ExtArgs>;
};
export type ClientPlanIncludeCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    client?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
    plan?: boolean | Prisma.PlanDefaultArgs<ExtArgs>;
};
export type ClientPlanIncludeUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    client?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    company?: boolean | Prisma.CompanyDefaultArgs<ExtArgs>;
    plan?: boolean | Prisma.PlanDefaultArgs<ExtArgs>;
};

export type $ClientPlanPayload<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    name: 'ClientPlan';
    objects: {
        appointments: Prisma.$AppointmentPayload<ExtArgs>[];
        client: Prisma.$UserPayload<ExtArgs>;
        company: Prisma.$CompanyPayload<ExtArgs>;
        plan: Prisma.$PlanPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            id: string;
            companyId: string;
            clientId: string;
            planId: string;
            startDate: Date;
            endDate: Date;
            usedBookings: number;
            status: $Enums.ClientPlanStatus;
            createdAt: Date;
            updatedAt: Date;
        },
        ExtArgs['result']['clientPlan']
    >;
    composites: {};
};

export type ClientPlanGetPayload<
    S extends boolean | null | undefined | ClientPlanDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$ClientPlanPayload, S>;

export type ClientPlanCountArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = Omit<ClientPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ClientPlanCountAggregateInputType | true;
};

export interface ClientPlanDelegate<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> {
    [K: symbol]: {
        types: Prisma.TypeMap<ExtArgs>['model']['ClientPlan'];
        meta: { name: 'ClientPlan' };
    };
    /**
     * Find zero or one ClientPlan that matches the filter.
     * @param {ClientPlanFindUniqueArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientPlanFindUniqueArgs>(
        args: Prisma.SelectSubset<T, ClientPlanFindUniqueArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find one ClientPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientPlanFindUniqueOrThrowArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientPlanFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<T, ClientPlanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first ClientPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanFindFirstArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientPlanFindFirstArgs>(
        args?: Prisma.SelectSubset<T, ClientPlanFindFirstArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first ClientPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanFindFirstOrThrowArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientPlanFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<T, ClientPlanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find zero or more ClientPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPlans
     * const clientPlans = await prisma.clientPlan.findMany()
     *
     * // Get first 10 ClientPlans
     * const clientPlans = await prisma.clientPlan.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const clientPlanWithIdOnly = await prisma.clientPlan.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ClientPlanFindManyArgs>(
        args?: Prisma.SelectSubset<T, ClientPlanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'findMany',
            GlobalOmitOptions
        >
    >;

    /**
     * Create a ClientPlan.
     * @param {ClientPlanCreateArgs} args - Arguments to create a ClientPlan.
     * @example
     * // Create one ClientPlan
     * const ClientPlan = await prisma.clientPlan.create({
     *   data: {
     *     // ... data to create a ClientPlan
     *   }
     * })
     *
     */
    create<T extends ClientPlanCreateArgs>(
        args: Prisma.SelectSubset<T, ClientPlanCreateArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'create',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Create many ClientPlans.
     * @param {ClientPlanCreateManyArgs} args - Arguments to create many ClientPlans.
     * @example
     * // Create many ClientPlans
     * const clientPlan = await prisma.clientPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ClientPlanCreateManyArgs>(
        args?: Prisma.SelectSubset<T, ClientPlanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Create many ClientPlans and returns the data saved in the database.
     * @param {ClientPlanCreateManyAndReturnArgs} args - Arguments to create many ClientPlans.
     * @example
     * // Create many ClientPlans
     * const clientPlan = await prisma.clientPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ClientPlans and only return the `id`
     * const clientPlanWithIdOnly = await prisma.clientPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ClientPlanCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<
            T,
            ClientPlanCreateManyAndReturnArgs<ExtArgs>
        >
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
        >
    >;

    /**
     * Delete a ClientPlan.
     * @param {ClientPlanDeleteArgs} args - Arguments to delete one ClientPlan.
     * @example
     * // Delete one ClientPlan
     * const ClientPlan = await prisma.clientPlan.delete({
     *   where: {
     *     // ... filter to delete one ClientPlan
     *   }
     * })
     *
     */
    delete<T extends ClientPlanDeleteArgs>(
        args: Prisma.SelectSubset<T, ClientPlanDeleteArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'delete',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Update one ClientPlan.
     * @param {ClientPlanUpdateArgs} args - Arguments to update one ClientPlan.
     * @example
     * // Update one ClientPlan
     * const clientPlan = await prisma.clientPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ClientPlanUpdateArgs>(
        args: Prisma.SelectSubset<T, ClientPlanUpdateArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'update',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Delete zero or more ClientPlans.
     * @param {ClientPlanDeleteManyArgs} args - Arguments to filter ClientPlans to delete.
     * @example
     * // Delete a few ClientPlans
     * const { count } = await prisma.clientPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ClientPlanDeleteManyArgs>(
        args?: Prisma.SelectSubset<T, ClientPlanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more ClientPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPlans
     * const clientPlan = await prisma.clientPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ClientPlanUpdateManyArgs>(
        args: Prisma.SelectSubset<T, ClientPlanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more ClientPlans and returns the data updated in the database.
     * @param {ClientPlanUpdateManyAndReturnArgs} args - Arguments to update many ClientPlans.
     * @example
     * // Update many ClientPlans
     * const clientPlan = await prisma.clientPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ClientPlans and only return the `id`
     * const clientPlanWithIdOnly = await prisma.clientPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ClientPlanUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<T, ClientPlanUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
        >
    >;

    /**
     * Create or update one ClientPlan.
     * @param {ClientPlanUpsertArgs} args - Arguments to update or create a ClientPlan.
     * @example
     * // Update or create a ClientPlan
     * const clientPlan = await prisma.clientPlan.upsert({
     *   create: {
     *     // ... data to create a ClientPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPlan we want to update
     *   }
     * })
     */
    upsert<T extends ClientPlanUpsertArgs>(
        args: Prisma.SelectSubset<T, ClientPlanUpsertArgs<ExtArgs>>
    ): Prisma.Prisma__ClientPlanClient<
        runtime.Types.Result.GetResult<
            Prisma.$ClientPlanPayload<ExtArgs>,
            T,
            'upsert',
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Count the number of ClientPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanCountArgs} args - Arguments to filter ClientPlans to count.
     * @example
     * // Count the number of ClientPlans
     * const count = await prisma.clientPlan.count({
     *   where: {
     *     // ... the filter for the ClientPlans we want to count
     *   }
     * })
     **/
    count<T extends ClientPlanCountArgs>(
        args?: Prisma.Subset<T, ClientPlanCountArgs>
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<
                      T['select'],
                      ClientPlanCountAggregateOutputType
                  >
            : number
    >;

    /**
     * Allows you to perform aggregations operations on a ClientPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClientPlanAggregateArgs>(
        args: Prisma.Subset<T, ClientPlanAggregateArgs>
    ): Prisma.PrismaPromise<GetClientPlanAggregateType<T>>;

    /**
     * Group by ClientPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends ClientPlanGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
            Prisma.Extends<'skip', Prisma.Keys<T>>,
            Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: ClientPlanGroupByArgs['orderBy'] }
            : { orderBy?: ClientPlanGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<
            Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
        >,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
              ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                          : [
                                Error,
                                'Field ',
                                P,
                                ` in "having" needs to be provided in "by"`,
                            ];
                }[HavingFields]
              : 'take' extends Prisma.Keys<T>
                ? 'orderBy' extends Prisma.Keys<T>
                    ? ByValid extends Prisma.True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                    : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Prisma.Keys<T>
                  ? 'orderBy' extends Prisma.Keys<T>
                      ? ByValid extends Prisma.True
                          ? {}
                          : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                            }[OrderFields]
                      : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends Prisma.True
                    ? {}
                    : {
                          [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
    >(
        args: Prisma.SubsetIntersection<T, ClientPlanGroupByArgs, OrderByArg> &
            InputErrors
    ): {} extends InputErrors
        ? GetClientPlanGroupByPayload<T>
        : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ClientPlan model
     */
    readonly fields: ClientPlanFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ClientPlan.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ClientPlanClient<
    T,
    Null = never,
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    appointments<T extends Prisma.ClientPlan$appointmentsArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.ClientPlan$appointmentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
        | runtime.Types.Result.GetResult<
              Prisma.$AppointmentPayload<ExtArgs>,
              T,
              'findMany',
              GlobalOmitOptions
          >
        | Null
    >;
    client<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__UserClient<
        | runtime.Types.Result.GetResult<
              Prisma.$UserPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    company<T extends Prisma.CompanyDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.CompanyDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__CompanyClient<
        | runtime.Types.Result.GetResult<
              Prisma.$CompanyPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    plan<T extends Prisma.PlanDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.PlanDefaultArgs<ExtArgs>>
    ): Prisma.Prisma__PlanClient<
        | runtime.Types.Result.GetResult<
              Prisma.$PlanPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
          >
        | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?:
            | ((value: T) => TResult1 | PromiseLike<TResult1>)
            | undefined
            | null,
        onrejected?:
            | ((reason: any) => TResult2 | PromiseLike<TResult2>)
            | undefined
            | null
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?:
            | ((reason: any) => TResult | PromiseLike<TResult>)
            | undefined
            | null
    ): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(
        onfinally?: (() => void) | undefined | null
    ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the ClientPlan model
 */
export interface ClientPlanFieldRefs {
    readonly id: Prisma.FieldRef<'ClientPlan', 'String'>;
    readonly companyId: Prisma.FieldRef<'ClientPlan', 'String'>;
    readonly clientId: Prisma.FieldRef<'ClientPlan', 'String'>;
    readonly planId: Prisma.FieldRef<'ClientPlan', 'String'>;
    readonly startDate: Prisma.FieldRef<'ClientPlan', 'DateTime'>;
    readonly endDate: Prisma.FieldRef<'ClientPlan', 'DateTime'>;
    readonly usedBookings: Prisma.FieldRef<'ClientPlan', 'Int'>;
    readonly status: Prisma.FieldRef<'ClientPlan', 'ClientPlanStatus'>;
    readonly createdAt: Prisma.FieldRef<'ClientPlan', 'DateTime'>;
    readonly updatedAt: Prisma.FieldRef<'ClientPlan', 'DateTime'>;
}

// Custom InputTypes
/**
 * ClientPlan findUnique
 */
export type ClientPlanFindUniqueArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * Filter, which ClientPlan to fetch.
     */
    where: Prisma.ClientPlanWhereUniqueInput;
};

/**
 * ClientPlan findUniqueOrThrow
 */
export type ClientPlanFindUniqueOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * Filter, which ClientPlan to fetch.
     */
    where: Prisma.ClientPlanWhereUniqueInput;
};

/**
 * ClientPlan findFirst
 */
export type ClientPlanFindFirstArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * Filter, which ClientPlan to fetch.
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?:
        | Prisma.ClientPlanOrderByWithRelationInput
        | Prisma.ClientPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ClientPlans.
     */
    cursor?: Prisma.ClientPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ClientPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientPlans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ClientPlans.
     */
    distinct?:
        | Prisma.ClientPlanScalarFieldEnum
        | Prisma.ClientPlanScalarFieldEnum[];
};

/**
 * ClientPlan findFirstOrThrow
 */
export type ClientPlanFindFirstOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * Filter, which ClientPlan to fetch.
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?:
        | Prisma.ClientPlanOrderByWithRelationInput
        | Prisma.ClientPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ClientPlans.
     */
    cursor?: Prisma.ClientPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ClientPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientPlans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ClientPlans.
     */
    distinct?:
        | Prisma.ClientPlanScalarFieldEnum
        | Prisma.ClientPlanScalarFieldEnum[];
};

/**
 * ClientPlan findMany
 */
export type ClientPlanFindManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * Filter, which ClientPlans to fetch.
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?:
        | Prisma.ClientPlanOrderByWithRelationInput
        | Prisma.ClientPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ClientPlans.
     */
    cursor?: Prisma.ClientPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` ClientPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClientPlans.
     */
    skip?: number;
    distinct?:
        | Prisma.ClientPlanScalarFieldEnum
        | Prisma.ClientPlanScalarFieldEnum[];
};

/**
 * ClientPlan create
 */
export type ClientPlanCreateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * The data needed to create a ClientPlan.
     */
    data: Prisma.XOR<
        Prisma.ClientPlanCreateInput,
        Prisma.ClientPlanUncheckedCreateInput
    >;
};

/**
 * ClientPlan createMany
 */
export type ClientPlanCreateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to create many ClientPlans.
     */
    data: Prisma.ClientPlanCreateManyInput | Prisma.ClientPlanCreateManyInput[];
    skipDuplicates?: boolean;
};

/**
 * ClientPlan createManyAndReturn
 */
export type ClientPlanCreateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * The data used to create many ClientPlans.
     */
    data: Prisma.ClientPlanCreateManyInput | Prisma.ClientPlanCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * ClientPlan update
 */
export type ClientPlanUpdateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * The data needed to update a ClientPlan.
     */
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateInput,
        Prisma.ClientPlanUncheckedUpdateInput
    >;
    /**
     * Choose, which ClientPlan to update.
     */
    where: Prisma.ClientPlanWhereUniqueInput;
};

/**
 * ClientPlan updateMany
 */
export type ClientPlanUpdateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to update ClientPlans.
     */
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateManyMutationInput,
        Prisma.ClientPlanUncheckedUpdateManyInput
    >;
    /**
     * Filter which ClientPlans to update
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * Limit how many ClientPlans to update.
     */
    limit?: number;
};

/**
 * ClientPlan updateManyAndReturn
 */
export type ClientPlanUpdateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * The data used to update ClientPlans.
     */
    data: Prisma.XOR<
        Prisma.ClientPlanUpdateManyMutationInput,
        Prisma.ClientPlanUncheckedUpdateManyInput
    >;
    /**
     * Filter which ClientPlans to update
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * Limit how many ClientPlans to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * ClientPlan upsert
 */
export type ClientPlanUpsertArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * The filter to search for the ClientPlan to update in case it exists.
     */
    where: Prisma.ClientPlanWhereUniqueInput;
    /**
     * In case the ClientPlan found by the `where` argument doesn't exist, create a new ClientPlan with this data.
     */
    create: Prisma.XOR<
        Prisma.ClientPlanCreateInput,
        Prisma.ClientPlanUncheckedCreateInput
    >;
    /**
     * In case the ClientPlan was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<
        Prisma.ClientPlanUpdateInput,
        Prisma.ClientPlanUncheckedUpdateInput
    >;
};

/**
 * ClientPlan delete
 */
export type ClientPlanDeleteArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
    /**
     * Filter which ClientPlan to delete.
     */
    where: Prisma.ClientPlanWhereUniqueInput;
};

/**
 * ClientPlan deleteMany
 */
export type ClientPlanDeleteManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which ClientPlans to delete
     */
    where?: Prisma.ClientPlanWhereInput;
    /**
     * Limit how many ClientPlans to delete.
     */
    limit?: number;
};

/**
 * ClientPlan.appointments
 */
export type ClientPlan$appointmentsArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: Prisma.AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: Prisma.AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AppointmentInclude<ExtArgs> | null;
    where?: Prisma.AppointmentWhereInput;
    orderBy?:
        | Prisma.AppointmentOrderByWithRelationInput
        | Prisma.AppointmentOrderByWithRelationInput[];
    cursor?: Prisma.AppointmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
        | Prisma.AppointmentScalarFieldEnum
        | Prisma.AppointmentScalarFieldEnum[];
};

/**
 * ClientPlan without action
 */
export type ClientPlanDefaultArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: Prisma.ClientPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: Prisma.ClientPlanOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ClientPlanInclude<ExtArgs> | null;
};
