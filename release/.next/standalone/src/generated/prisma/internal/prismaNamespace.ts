/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from '@prisma/client/runtime/library';
import type * as Prisma from '../models';
import { type PrismaClient } from './class';

export type * from '../models';

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
    runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
    runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
    runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
    runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
    runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
    runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Metrics
 */
export type Metrics = runtime.Metrics;
export type Metric<T> = runtime.Metric<T>;
export type MetricHistogram = runtime.MetricHistogram;
export type MetricHistogramBucket = runtime.MetricHistogramBucket;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
    T,
    F
>;
export type Payload<
    T,
    F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
    T,
    A,
    F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
    client: string;
    engine: string;
};

/**
 * Prisma Client JS version: 6.18.0
 * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
 */
export const prismaVersion: PrismaVersion = {
    client: '6.18.0',
    engine: '34b5a692b7bd79939a9a2c3ef97d816e749cda2f',
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
    DbNull: runtime.objectEnumValues.classes.DbNull as new (
        secret: never
    ) => typeof runtime.objectEnumValues.instances.DbNull,
    JsonNull: runtime.objectEnumValues.classes.JsonNull as new (
        secret: never
    ) => typeof runtime.objectEnumValues.instances.JsonNull,
    AnyNull: runtime.objectEnumValues.classes.AnyNull as new (
        secret: never
    ) => typeof runtime.objectEnumValues.instances.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull;
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull;
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull;

type SelectAndInclude = {
    select: any;
    include: any;
};

type SelectAndOmit = {
    select: any;
    omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
    ? U extends object
        ? (Without<T, U> & U) | (Without<U, T> & T)
        : U
    : T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
    T extends Array<any>
        ? False
        : T extends Date
          ? False
          : T extends Uint8Array
            ? False
            : T extends BigInt
              ? False
              : T extends object
                ? True
                : False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
        // Merge all but K
        [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
}[strict];

export type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
    ? I
    : never;

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
    Overwrite<
        U,
        {
            [K in keyof U]-?: At<U, K>;
        }
    >
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
          [K in keyof A]: A[K];
      } & {};

export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
    [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
        ?
              | (K extends keyof O ? { [P in K]: O[P] } & O : O)
              | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
        : never
>;

type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
        0: 0;
        1: 1;
    };
    1: {
        0: 1;
        1: 1;
    };
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
    ? {
          [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
    [K in keyof T]: Or<
        Or<Extends<'OR', K>, Extends<'AND', K>>,
        Extends<'NOT', K>
    > extends True
        ? // infer is only needed to not hit TS limit
          // based on the brilliant idea of Pierre-Antoine Mills
          // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
          T[K] extends infer TK
            ? GetHavingFields<
                  UnEnumerate<TK> extends object
                      ? Merge<UnEnumerate<TK>>
                      : never
              >
            : never
        : {} extends FieldPaths<T[K]>
          ? never
          : K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

export const ModelName = {
    Company: 'Company',
    CompanyMember: 'CompanyMember',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Unit: 'Unit',
    CustomerLevelConfig: 'CustomerLevelConfig',
    CustomerLevelRule: 'CustomerLevelRule',
    CustomerLevelState: 'CustomerLevelState',
    CustomerLevelPeriod: 'CustomerLevelPeriod',
    ProfessionalUnit: 'ProfessionalUnit',
    UnitWeeklyAvailability: 'UnitWeeklyAvailability',
    UnitWeeklyTimeInterval: 'UnitWeeklyTimeInterval',
    UnitDailyAvailability: 'UnitDailyAvailability',
    UnitDailyTimeInterval: 'UnitDailyTimeInterval',
    Professional: 'Professional',
    Service: 'Service',
    ServiceProfessional: 'ServiceProfessional',
    Plan: 'Plan',
    PlanService: 'PlanService',
    ClientPlan: 'ClientPlan',
    Appointment: 'Appointment',
    ProfessionalCancellationFee: 'ProfessionalCancellationFee',
    Product: 'Product',
    ProductDiscountByLevel: 'ProductDiscountByLevel',
    ProductSale: 'ProductSale',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Expense: 'Expense',
    ProfessionalWeeklyAvailability: 'ProfessionalWeeklyAvailability',
    ProfessionalWeeklyTimeInterval: 'ProfessionalWeeklyTimeInterval',
    ProfessionalDailyAvailability: 'ProfessionalDailyAvailability',
    ProfessionalDailyTimeInterval: 'ProfessionalDailyTimeInterval',
    AppointmentReview: 'AppointmentReview',
    ReviewTag: 'ReviewTag',
    AppointmentReviewTag: 'AppointmentReviewTag',
    AdminAccess: 'AdminAccess',
    AnalyticsEvent: 'AnalyticsEvent',
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils
    .Fn<
    { extArgs: runtime.Types.Extensions.InternalArgs },
    runtime.Types.Utils.Record<string, any>
> {
    returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>;
}

export type TypeMap<
    ExtArgs extends runtime.Types.Extensions.InternalArgs =
        runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> = {
    globalOmitOptions: {
        omit: GlobalOmitOptions;
    };
    meta: {
        modelProps:
            | 'company'
            | 'companyMember'
            | 'user'
            | 'account'
            | 'session'
            | 'verificationToken'
            | 'unit'
            | 'customerLevelConfig'
            | 'customerLevelRule'
            | 'customerLevelState'
            | 'customerLevelPeriod'
            | 'professionalUnit'
            | 'unitWeeklyAvailability'
            | 'unitWeeklyTimeInterval'
            | 'unitDailyAvailability'
            | 'unitDailyTimeInterval'
            | 'professional'
            | 'service'
            | 'serviceProfessional'
            | 'plan'
            | 'planService'
            | 'clientPlan'
            | 'appointment'
            | 'professionalCancellationFee'
            | 'product'
            | 'productDiscountByLevel'
            | 'productSale'
            | 'order'
            | 'orderItem'
            | 'expense'
            | 'professionalWeeklyAvailability'
            | 'professionalWeeklyTimeInterval'
            | 'professionalDailyAvailability'
            | 'professionalDailyTimeInterval'
            | 'appointmentReview'
            | 'reviewTag'
            | 'appointmentReviewTag'
            | 'adminAccess'
            | 'analyticsEvent';
        txIsolationLevel: TransactionIsolationLevel;
    };
    model: {
        Company: {
            payload: Prisma.$CompanyPayload<ExtArgs>;
            fields: Prisma.CompanyFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.CompanyFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>;
                };
                findFirst: {
                    args: Prisma.CompanyFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>;
                };
                findMany: {
                    args: Prisma.CompanyFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[];
                };
                create: {
                    args: Prisma.CompanyCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>;
                };
                createMany: {
                    args: Prisma.CompanyCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[];
                };
                delete: {
                    args: Prisma.CompanyDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>;
                };
                update: {
                    args: Prisma.CompanyUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>;
                };
                deleteMany: {
                    args: Prisma.CompanyDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.CompanyUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[];
                };
                upsert: {
                    args: Prisma.CompanyUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>;
                };
                aggregate: {
                    args: Prisma.CompanyAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>;
                };
                groupBy: {
                    args: Prisma.CompanyGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[];
                };
                count: {
                    args: Prisma.CompanyCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType>
                        | number;
                };
            };
        };
        CompanyMember: {
            payload: Prisma.$CompanyMemberPayload<ExtArgs>;
            fields: Prisma.CompanyMemberFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.CompanyMemberFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.CompanyMemberFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>;
                };
                findFirst: {
                    args: Prisma.CompanyMemberFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.CompanyMemberFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>;
                };
                findMany: {
                    args: Prisma.CompanyMemberFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>[];
                };
                create: {
                    args: Prisma.CompanyMemberCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>;
                };
                createMany: {
                    args: Prisma.CompanyMemberCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.CompanyMemberCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>[];
                };
                delete: {
                    args: Prisma.CompanyMemberDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>;
                };
                update: {
                    args: Prisma.CompanyMemberUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>;
                };
                deleteMany: {
                    args: Prisma.CompanyMemberDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.CompanyMemberUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.CompanyMemberUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>[];
                };
                upsert: {
                    args: Prisma.CompanyMemberUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyMemberPayload>;
                };
                aggregate: {
                    args: Prisma.CompanyMemberAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyMember>;
                };
                groupBy: {
                    args: Prisma.CompanyMemberGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.CompanyMemberGroupByOutputType>[];
                };
                count: {
                    args: Prisma.CompanyMemberCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.CompanyMemberCountAggregateOutputType>
                        | number;
                };
            };
        };
        User: {
            payload: Prisma.$UserPayload<ExtArgs>;
            fields: Prisma.UserFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.UserFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
                };
                findFirst: {
                    args: Prisma.UserFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
                };
                findMany: {
                    args: Prisma.UserFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
                };
                create: {
                    args: Prisma.UserCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
                };
                createMany: {
                    args: Prisma.UserCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
                };
                delete: {
                    args: Prisma.UserDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
                };
                update: {
                    args: Prisma.UserUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
                };
                deleteMany: {
                    args: Prisma.UserDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.UserUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
                };
                upsert: {
                    args: Prisma.UserUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
                };
                aggregate: {
                    args: Prisma.UserAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
                };
                groupBy: {
                    args: Prisma.UserGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
                };
                count: {
                    args: Prisma.UserCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
                        | number;
                };
            };
        };
        Account: {
            payload: Prisma.$AccountPayload<ExtArgs>;
            fields: Prisma.AccountFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.AccountFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
                };
                findFirst: {
                    args: Prisma.AccountFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
                };
                findMany: {
                    args: Prisma.AccountFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
                };
                create: {
                    args: Prisma.AccountCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
                };
                createMany: {
                    args: Prisma.AccountCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
                };
                delete: {
                    args: Prisma.AccountDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
                };
                update: {
                    args: Prisma.AccountUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
                };
                deleteMany: {
                    args: Prisma.AccountDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.AccountUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
                };
                upsert: {
                    args: Prisma.AccountUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
                };
                aggregate: {
                    args: Prisma.AccountAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>;
                };
                groupBy: {
                    args: Prisma.AccountGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[];
                };
                count: {
                    args: Prisma.AccountCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType>
                        | number;
                };
            };
        };
        Session: {
            payload: Prisma.$SessionPayload<ExtArgs>;
            fields: Prisma.SessionFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.SessionFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
                };
                findFirst: {
                    args: Prisma.SessionFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
                };
                findMany: {
                    args: Prisma.SessionFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
                };
                create: {
                    args: Prisma.SessionCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
                };
                createMany: {
                    args: Prisma.SessionCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
                };
                delete: {
                    args: Prisma.SessionDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
                };
                update: {
                    args: Prisma.SessionUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
                };
                deleteMany: {
                    args: Prisma.SessionDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.SessionUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
                };
                upsert: {
                    args: Prisma.SessionUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
                };
                aggregate: {
                    args: Prisma.SessionAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateSession>;
                };
                groupBy: {
                    args: Prisma.SessionGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[];
                };
                count: {
                    args: Prisma.SessionCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType>
                        | number;
                };
            };
        };
        VerificationToken: {
            payload: Prisma.$VerificationTokenPayload<ExtArgs>;
            fields: Prisma.VerificationTokenFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
                };
                findFirst: {
                    args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
                };
                findMany: {
                    args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
                };
                create: {
                    args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
                };
                createMany: {
                    args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
                };
                delete: {
                    args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
                };
                update: {
                    args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
                };
                deleteMany: {
                    args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
                };
                upsert: {
                    args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
                };
                aggregate: {
                    args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>;
                };
                groupBy: {
                    args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[];
                };
                count: {
                    args: Prisma.VerificationTokenCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType>
                        | number;
                };
            };
        };
        Unit: {
            payload: Prisma.$UnitPayload<ExtArgs>;
            fields: Prisma.UnitFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.UnitFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>;
                };
                findFirst: {
                    args: Prisma.UnitFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>;
                };
                findMany: {
                    args: Prisma.UnitFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>[];
                };
                create: {
                    args: Prisma.UnitCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>;
                };
                createMany: {
                    args: Prisma.UnitCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>[];
                };
                delete: {
                    args: Prisma.UnitDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>;
                };
                update: {
                    args: Prisma.UnitUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>;
                };
                deleteMany: {
                    args: Prisma.UnitDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.UnitUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>[];
                };
                upsert: {
                    args: Prisma.UnitUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>;
                };
                aggregate: {
                    args: Prisma.UnitAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateUnit>;
                };
                groupBy: {
                    args: Prisma.UnitGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.UnitGroupByOutputType>[];
                };
                count: {
                    args: Prisma.UnitCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.UnitCountAggregateOutputType>
                        | number;
                };
            };
        };
        CustomerLevelConfig: {
            payload: Prisma.$CustomerLevelConfigPayload<ExtArgs>;
            fields: Prisma.CustomerLevelConfigFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.CustomerLevelConfigFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.CustomerLevelConfigFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>;
                };
                findFirst: {
                    args: Prisma.CustomerLevelConfigFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.CustomerLevelConfigFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>;
                };
                findMany: {
                    args: Prisma.CustomerLevelConfigFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>[];
                };
                create: {
                    args: Prisma.CustomerLevelConfigCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>;
                };
                createMany: {
                    args: Prisma.CustomerLevelConfigCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.CustomerLevelConfigCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>[];
                };
                delete: {
                    args: Prisma.CustomerLevelConfigDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>;
                };
                update: {
                    args: Prisma.CustomerLevelConfigUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>;
                };
                deleteMany: {
                    args: Prisma.CustomerLevelConfigDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.CustomerLevelConfigUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.CustomerLevelConfigUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>[];
                };
                upsert: {
                    args: Prisma.CustomerLevelConfigUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelConfigPayload>;
                };
                aggregate: {
                    args: Prisma.CustomerLevelConfigAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerLevelConfig>;
                };
                groupBy: {
                    args: Prisma.CustomerLevelConfigGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.CustomerLevelConfigGroupByOutputType>[];
                };
                count: {
                    args: Prisma.CustomerLevelConfigCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.CustomerLevelConfigCountAggregateOutputType>
                        | number;
                };
            };
        };
        CustomerLevelRule: {
            payload: Prisma.$CustomerLevelRulePayload<ExtArgs>;
            fields: Prisma.CustomerLevelRuleFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.CustomerLevelRuleFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.CustomerLevelRuleFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>;
                };
                findFirst: {
                    args: Prisma.CustomerLevelRuleFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.CustomerLevelRuleFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>;
                };
                findMany: {
                    args: Prisma.CustomerLevelRuleFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>[];
                };
                create: {
                    args: Prisma.CustomerLevelRuleCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>;
                };
                createMany: {
                    args: Prisma.CustomerLevelRuleCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.CustomerLevelRuleCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>[];
                };
                delete: {
                    args: Prisma.CustomerLevelRuleDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>;
                };
                update: {
                    args: Prisma.CustomerLevelRuleUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>;
                };
                deleteMany: {
                    args: Prisma.CustomerLevelRuleDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.CustomerLevelRuleUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.CustomerLevelRuleUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>[];
                };
                upsert: {
                    args: Prisma.CustomerLevelRuleUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelRulePayload>;
                };
                aggregate: {
                    args: Prisma.CustomerLevelRuleAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerLevelRule>;
                };
                groupBy: {
                    args: Prisma.CustomerLevelRuleGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.CustomerLevelRuleGroupByOutputType>[];
                };
                count: {
                    args: Prisma.CustomerLevelRuleCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.CustomerLevelRuleCountAggregateOutputType>
                        | number;
                };
            };
        };
        CustomerLevelState: {
            payload: Prisma.$CustomerLevelStatePayload<ExtArgs>;
            fields: Prisma.CustomerLevelStateFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.CustomerLevelStateFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.CustomerLevelStateFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>;
                };
                findFirst: {
                    args: Prisma.CustomerLevelStateFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.CustomerLevelStateFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>;
                };
                findMany: {
                    args: Prisma.CustomerLevelStateFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>[];
                };
                create: {
                    args: Prisma.CustomerLevelStateCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>;
                };
                createMany: {
                    args: Prisma.CustomerLevelStateCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.CustomerLevelStateCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>[];
                };
                delete: {
                    args: Prisma.CustomerLevelStateDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>;
                };
                update: {
                    args: Prisma.CustomerLevelStateUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>;
                };
                deleteMany: {
                    args: Prisma.CustomerLevelStateDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.CustomerLevelStateUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.CustomerLevelStateUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>[];
                };
                upsert: {
                    args: Prisma.CustomerLevelStateUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelStatePayload>;
                };
                aggregate: {
                    args: Prisma.CustomerLevelStateAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerLevelState>;
                };
                groupBy: {
                    args: Prisma.CustomerLevelStateGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.CustomerLevelStateGroupByOutputType>[];
                };
                count: {
                    args: Prisma.CustomerLevelStateCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.CustomerLevelStateCountAggregateOutputType>
                        | number;
                };
            };
        };
        CustomerLevelPeriod: {
            payload: Prisma.$CustomerLevelPeriodPayload<ExtArgs>;
            fields: Prisma.CustomerLevelPeriodFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.CustomerLevelPeriodFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.CustomerLevelPeriodFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>;
                };
                findFirst: {
                    args: Prisma.CustomerLevelPeriodFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.CustomerLevelPeriodFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>;
                };
                findMany: {
                    args: Prisma.CustomerLevelPeriodFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>[];
                };
                create: {
                    args: Prisma.CustomerLevelPeriodCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>;
                };
                createMany: {
                    args: Prisma.CustomerLevelPeriodCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.CustomerLevelPeriodCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>[];
                };
                delete: {
                    args: Prisma.CustomerLevelPeriodDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>;
                };
                update: {
                    args: Prisma.CustomerLevelPeriodUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>;
                };
                deleteMany: {
                    args: Prisma.CustomerLevelPeriodDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.CustomerLevelPeriodUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.CustomerLevelPeriodUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>[];
                };
                upsert: {
                    args: Prisma.CustomerLevelPeriodUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerLevelPeriodPayload>;
                };
                aggregate: {
                    args: Prisma.CustomerLevelPeriodAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerLevelPeriod>;
                };
                groupBy: {
                    args: Prisma.CustomerLevelPeriodGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.CustomerLevelPeriodGroupByOutputType>[];
                };
                count: {
                    args: Prisma.CustomerLevelPeriodCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.CustomerLevelPeriodCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProfessionalUnit: {
            payload: Prisma.$ProfessionalUnitPayload<ExtArgs>;
            fields: Prisma.ProfessionalUnitFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalUnitFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalUnitFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalUnitFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalUnitFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalUnitFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>[];
                };
                create: {
                    args: Prisma.ProfessionalUnitCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalUnitCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalUnitCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalUnitDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>;
                };
                update: {
                    args: Prisma.ProfessionalUnitUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalUnitDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalUnitUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalUnitUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalUnitUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalUnitPayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalUnitAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessionalUnit>;
                };
                groupBy: {
                    args: Prisma.ProfessionalUnitGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalUnitGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalUnitCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalUnitCountAggregateOutputType>
                        | number;
                };
            };
        };
        UnitWeeklyAvailability: {
            payload: Prisma.$UnitWeeklyAvailabilityPayload<ExtArgs>;
            fields: Prisma.UnitWeeklyAvailabilityFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.UnitWeeklyAvailabilityFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.UnitWeeklyAvailabilityFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>;
                };
                findFirst: {
                    args: Prisma.UnitWeeklyAvailabilityFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.UnitWeeklyAvailabilityFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>;
                };
                findMany: {
                    args: Prisma.UnitWeeklyAvailabilityFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>[];
                };
                create: {
                    args: Prisma.UnitWeeklyAvailabilityCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>;
                };
                createMany: {
                    args: Prisma.UnitWeeklyAvailabilityCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.UnitWeeklyAvailabilityCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>[];
                };
                delete: {
                    args: Prisma.UnitWeeklyAvailabilityDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>;
                };
                update: {
                    args: Prisma.UnitWeeklyAvailabilityUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>;
                };
                deleteMany: {
                    args: Prisma.UnitWeeklyAvailabilityDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.UnitWeeklyAvailabilityUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.UnitWeeklyAvailabilityUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>[];
                };
                upsert: {
                    args: Prisma.UnitWeeklyAvailabilityUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyAvailabilityPayload>;
                };
                aggregate: {
                    args: Prisma.UnitWeeklyAvailabilityAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateUnitWeeklyAvailability>;
                };
                groupBy: {
                    args: Prisma.UnitWeeklyAvailabilityGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.UnitWeeklyAvailabilityGroupByOutputType>[];
                };
                count: {
                    args: Prisma.UnitWeeklyAvailabilityCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.UnitWeeklyAvailabilityCountAggregateOutputType>
                        | number;
                };
            };
        };
        UnitWeeklyTimeInterval: {
            payload: Prisma.$UnitWeeklyTimeIntervalPayload<ExtArgs>;
            fields: Prisma.UnitWeeklyTimeIntervalFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.UnitWeeklyTimeIntervalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.UnitWeeklyTimeIntervalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>;
                };
                findFirst: {
                    args: Prisma.UnitWeeklyTimeIntervalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.UnitWeeklyTimeIntervalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>;
                };
                findMany: {
                    args: Prisma.UnitWeeklyTimeIntervalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>[];
                };
                create: {
                    args: Prisma.UnitWeeklyTimeIntervalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>;
                };
                createMany: {
                    args: Prisma.UnitWeeklyTimeIntervalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.UnitWeeklyTimeIntervalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>[];
                };
                delete: {
                    args: Prisma.UnitWeeklyTimeIntervalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>;
                };
                update: {
                    args: Prisma.UnitWeeklyTimeIntervalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>;
                };
                deleteMany: {
                    args: Prisma.UnitWeeklyTimeIntervalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.UnitWeeklyTimeIntervalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.UnitWeeklyTimeIntervalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>[];
                };
                upsert: {
                    args: Prisma.UnitWeeklyTimeIntervalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitWeeklyTimeIntervalPayload>;
                };
                aggregate: {
                    args: Prisma.UnitWeeklyTimeIntervalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateUnitWeeklyTimeInterval>;
                };
                groupBy: {
                    args: Prisma.UnitWeeklyTimeIntervalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.UnitWeeklyTimeIntervalGroupByOutputType>[];
                };
                count: {
                    args: Prisma.UnitWeeklyTimeIntervalCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.UnitWeeklyTimeIntervalCountAggregateOutputType>
                        | number;
                };
            };
        };
        UnitDailyAvailability: {
            payload: Prisma.$UnitDailyAvailabilityPayload<ExtArgs>;
            fields: Prisma.UnitDailyAvailabilityFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.UnitDailyAvailabilityFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.UnitDailyAvailabilityFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>;
                };
                findFirst: {
                    args: Prisma.UnitDailyAvailabilityFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.UnitDailyAvailabilityFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>;
                };
                findMany: {
                    args: Prisma.UnitDailyAvailabilityFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>[];
                };
                create: {
                    args: Prisma.UnitDailyAvailabilityCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>;
                };
                createMany: {
                    args: Prisma.UnitDailyAvailabilityCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.UnitDailyAvailabilityCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>[];
                };
                delete: {
                    args: Prisma.UnitDailyAvailabilityDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>;
                };
                update: {
                    args: Prisma.UnitDailyAvailabilityUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>;
                };
                deleteMany: {
                    args: Prisma.UnitDailyAvailabilityDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.UnitDailyAvailabilityUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.UnitDailyAvailabilityUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>[];
                };
                upsert: {
                    args: Prisma.UnitDailyAvailabilityUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyAvailabilityPayload>;
                };
                aggregate: {
                    args: Prisma.UnitDailyAvailabilityAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateUnitDailyAvailability>;
                };
                groupBy: {
                    args: Prisma.UnitDailyAvailabilityGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.UnitDailyAvailabilityGroupByOutputType>[];
                };
                count: {
                    args: Prisma.UnitDailyAvailabilityCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.UnitDailyAvailabilityCountAggregateOutputType>
                        | number;
                };
            };
        };
        UnitDailyTimeInterval: {
            payload: Prisma.$UnitDailyTimeIntervalPayload<ExtArgs>;
            fields: Prisma.UnitDailyTimeIntervalFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.UnitDailyTimeIntervalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.UnitDailyTimeIntervalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>;
                };
                findFirst: {
                    args: Prisma.UnitDailyTimeIntervalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.UnitDailyTimeIntervalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>;
                };
                findMany: {
                    args: Prisma.UnitDailyTimeIntervalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>[];
                };
                create: {
                    args: Prisma.UnitDailyTimeIntervalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>;
                };
                createMany: {
                    args: Prisma.UnitDailyTimeIntervalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.UnitDailyTimeIntervalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>[];
                };
                delete: {
                    args: Prisma.UnitDailyTimeIntervalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>;
                };
                update: {
                    args: Prisma.UnitDailyTimeIntervalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>;
                };
                deleteMany: {
                    args: Prisma.UnitDailyTimeIntervalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.UnitDailyTimeIntervalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.UnitDailyTimeIntervalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>[];
                };
                upsert: {
                    args: Prisma.UnitDailyTimeIntervalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitDailyTimeIntervalPayload>;
                };
                aggregate: {
                    args: Prisma.UnitDailyTimeIntervalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateUnitDailyTimeInterval>;
                };
                groupBy: {
                    args: Prisma.UnitDailyTimeIntervalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.UnitDailyTimeIntervalGroupByOutputType>[];
                };
                count: {
                    args: Prisma.UnitDailyTimeIntervalCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.UnitDailyTimeIntervalCountAggregateOutputType>
                        | number;
                };
            };
        };
        Professional: {
            payload: Prisma.$ProfessionalPayload<ExtArgs>;
            fields: Prisma.ProfessionalFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>[];
                };
                create: {
                    args: Prisma.ProfessionalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>;
                };
                update: {
                    args: Prisma.ProfessionalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalPayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessional>;
                };
                groupBy: {
                    args: Prisma.ProfessionalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalCountAggregateOutputType>
                        | number;
                };
            };
        };
        Service: {
            payload: Prisma.$ServicePayload<ExtArgs>;
            fields: Prisma.ServiceFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
                };
                findFirst: {
                    args: Prisma.ServiceFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
                };
                findMany: {
                    args: Prisma.ServiceFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[];
                };
                create: {
                    args: Prisma.ServiceCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
                };
                createMany: {
                    args: Prisma.ServiceCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[];
                };
                delete: {
                    args: Prisma.ServiceDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
                };
                update: {
                    args: Prisma.ServiceUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
                };
                deleteMany: {
                    args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[];
                };
                upsert: {
                    args: Prisma.ServiceUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
                };
                aggregate: {
                    args: Prisma.ServiceAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateService>;
                };
                groupBy: {
                    args: Prisma.ServiceGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ServiceCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType>
                        | number;
                };
            };
        };
        ServiceProfessional: {
            payload: Prisma.$ServiceProfessionalPayload<ExtArgs>;
            fields: Prisma.ServiceProfessionalFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ServiceProfessionalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ServiceProfessionalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>;
                };
                findFirst: {
                    args: Prisma.ServiceProfessionalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ServiceProfessionalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>;
                };
                findMany: {
                    args: Prisma.ServiceProfessionalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>[];
                };
                create: {
                    args: Prisma.ServiceProfessionalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>;
                };
                createMany: {
                    args: Prisma.ServiceProfessionalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ServiceProfessionalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>[];
                };
                delete: {
                    args: Prisma.ServiceProfessionalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>;
                };
                update: {
                    args: Prisma.ServiceProfessionalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>;
                };
                deleteMany: {
                    args: Prisma.ServiceProfessionalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ServiceProfessionalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ServiceProfessionalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>[];
                };
                upsert: {
                    args: Prisma.ServiceProfessionalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceProfessionalPayload>;
                };
                aggregate: {
                    args: Prisma.ServiceProfessionalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateServiceProfessional>;
                };
                groupBy: {
                    args: Prisma.ServiceProfessionalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ServiceProfessionalGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ServiceProfessionalCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ServiceProfessionalCountAggregateOutputType>
                        | number;
                };
            };
        };
        Plan: {
            payload: Prisma.$PlanPayload<ExtArgs>;
            fields: Prisma.PlanFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.PlanFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>;
                };
                findFirst: {
                    args: Prisma.PlanFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>;
                };
                findMany: {
                    args: Prisma.PlanFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>[];
                };
                create: {
                    args: Prisma.PlanCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>;
                };
                createMany: {
                    args: Prisma.PlanCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>[];
                };
                delete: {
                    args: Prisma.PlanDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>;
                };
                update: {
                    args: Prisma.PlanUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>;
                };
                deleteMany: {
                    args: Prisma.PlanDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.PlanUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>[];
                };
                upsert: {
                    args: Prisma.PlanUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanPayload>;
                };
                aggregate: {
                    args: Prisma.PlanAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregatePlan>;
                };
                groupBy: {
                    args: Prisma.PlanGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.PlanGroupByOutputType>[];
                };
                count: {
                    args: Prisma.PlanCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.PlanCountAggregateOutputType>
                        | number;
                };
            };
        };
        PlanService: {
            payload: Prisma.$PlanServicePayload<ExtArgs>;
            fields: Prisma.PlanServiceFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.PlanServiceFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.PlanServiceFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>;
                };
                findFirst: {
                    args: Prisma.PlanServiceFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.PlanServiceFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>;
                };
                findMany: {
                    args: Prisma.PlanServiceFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>[];
                };
                create: {
                    args: Prisma.PlanServiceCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>;
                };
                createMany: {
                    args: Prisma.PlanServiceCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.PlanServiceCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>[];
                };
                delete: {
                    args: Prisma.PlanServiceDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>;
                };
                update: {
                    args: Prisma.PlanServiceUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>;
                };
                deleteMany: {
                    args: Prisma.PlanServiceDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.PlanServiceUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.PlanServiceUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>[];
                };
                upsert: {
                    args: Prisma.PlanServiceUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanServicePayload>;
                };
                aggregate: {
                    args: Prisma.PlanServiceAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregatePlanService>;
                };
                groupBy: {
                    args: Prisma.PlanServiceGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.PlanServiceGroupByOutputType>[];
                };
                count: {
                    args: Prisma.PlanServiceCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.PlanServiceCountAggregateOutputType>
                        | number;
                };
            };
        };
        ClientPlan: {
            payload: Prisma.$ClientPlanPayload<ExtArgs>;
            fields: Prisma.ClientPlanFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ClientPlanFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ClientPlanFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>;
                };
                findFirst: {
                    args: Prisma.ClientPlanFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ClientPlanFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>;
                };
                findMany: {
                    args: Prisma.ClientPlanFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>[];
                };
                create: {
                    args: Prisma.ClientPlanCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>;
                };
                createMany: {
                    args: Prisma.ClientPlanCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ClientPlanCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>[];
                };
                delete: {
                    args: Prisma.ClientPlanDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>;
                };
                update: {
                    args: Prisma.ClientPlanUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>;
                };
                deleteMany: {
                    args: Prisma.ClientPlanDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ClientPlanUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ClientPlanUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>[];
                };
                upsert: {
                    args: Prisma.ClientPlanUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPlanPayload>;
                };
                aggregate: {
                    args: Prisma.ClientPlanAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateClientPlan>;
                };
                groupBy: {
                    args: Prisma.ClientPlanGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ClientPlanGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ClientPlanCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ClientPlanCountAggregateOutputType>
                        | number;
                };
            };
        };
        Appointment: {
            payload: Prisma.$AppointmentPayload<ExtArgs>;
            fields: Prisma.AppointmentFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.AppointmentFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
                };
                findFirst: {
                    args: Prisma.AppointmentFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
                };
                findMany: {
                    args: Prisma.AppointmentFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[];
                };
                create: {
                    args: Prisma.AppointmentCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
                };
                createMany: {
                    args: Prisma.AppointmentCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[];
                };
                delete: {
                    args: Prisma.AppointmentDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
                };
                update: {
                    args: Prisma.AppointmentUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
                };
                deleteMany: {
                    args: Prisma.AppointmentDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.AppointmentUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[];
                };
                upsert: {
                    args: Prisma.AppointmentUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
                };
                aggregate: {
                    args: Prisma.AppointmentAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateAppointment>;
                };
                groupBy: {
                    args: Prisma.AppointmentGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AppointmentGroupByOutputType>[];
                };
                count: {
                    args: Prisma.AppointmentCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.AppointmentCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProfessionalCancellationFee: {
            payload: Prisma.$ProfessionalCancellationFeePayload<ExtArgs>;
            fields: Prisma.ProfessionalCancellationFeeFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalCancellationFeeFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalCancellationFeeFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalCancellationFeeFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalCancellationFeeFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalCancellationFeeFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>[];
                };
                create: {
                    args: Prisma.ProfessionalCancellationFeeCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalCancellationFeeCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalCancellationFeeCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalCancellationFeeDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>;
                };
                update: {
                    args: Prisma.ProfessionalCancellationFeeUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalCancellationFeeDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalCancellationFeeUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalCancellationFeeUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalCancellationFeeUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalCancellationFeePayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalCancellationFeeAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessionalCancellationFee>;
                };
                groupBy: {
                    args: Prisma.ProfessionalCancellationFeeGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalCancellationFeeGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalCancellationFeeCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalCancellationFeeCountAggregateOutputType>
                        | number;
                };
            };
        };
        Product: {
            payload: Prisma.$ProductPayload<ExtArgs>;
            fields: Prisma.ProductFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProductFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>;
                };
                findFirst: {
                    args: Prisma.ProductFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>;
                };
                findMany: {
                    args: Prisma.ProductFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[];
                };
                create: {
                    args: Prisma.ProductCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>;
                };
                createMany: {
                    args: Prisma.ProductCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[];
                };
                delete: {
                    args: Prisma.ProductDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>;
                };
                update: {
                    args: Prisma.ProductUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>;
                };
                deleteMany: {
                    args: Prisma.ProductDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProductUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[];
                };
                upsert: {
                    args: Prisma.ProductUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>;
                };
                aggregate: {
                    args: Prisma.ProductAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProduct>;
                };
                groupBy: {
                    args: Prisma.ProductGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProductGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProductCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProductCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProductDiscountByLevel: {
            payload: Prisma.$ProductDiscountByLevelPayload<ExtArgs>;
            fields: Prisma.ProductDiscountByLevelFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProductDiscountByLevelFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProductDiscountByLevelFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>;
                };
                findFirst: {
                    args: Prisma.ProductDiscountByLevelFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProductDiscountByLevelFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>;
                };
                findMany: {
                    args: Prisma.ProductDiscountByLevelFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>[];
                };
                create: {
                    args: Prisma.ProductDiscountByLevelCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>;
                };
                createMany: {
                    args: Prisma.ProductDiscountByLevelCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProductDiscountByLevelCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>[];
                };
                delete: {
                    args: Prisma.ProductDiscountByLevelDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>;
                };
                update: {
                    args: Prisma.ProductDiscountByLevelUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>;
                };
                deleteMany: {
                    args: Prisma.ProductDiscountByLevelDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProductDiscountByLevelUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProductDiscountByLevelUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>[];
                };
                upsert: {
                    args: Prisma.ProductDiscountByLevelUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDiscountByLevelPayload>;
                };
                aggregate: {
                    args: Prisma.ProductDiscountByLevelAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProductDiscountByLevel>;
                };
                groupBy: {
                    args: Prisma.ProductDiscountByLevelGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProductDiscountByLevelGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProductDiscountByLevelCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProductDiscountByLevelCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProductSale: {
            payload: Prisma.$ProductSalePayload<ExtArgs>;
            fields: Prisma.ProductSaleFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProductSaleFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProductSaleFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>;
                };
                findFirst: {
                    args: Prisma.ProductSaleFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProductSaleFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>;
                };
                findMany: {
                    args: Prisma.ProductSaleFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>[];
                };
                create: {
                    args: Prisma.ProductSaleCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>;
                };
                createMany: {
                    args: Prisma.ProductSaleCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProductSaleCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>[];
                };
                delete: {
                    args: Prisma.ProductSaleDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>;
                };
                update: {
                    args: Prisma.ProductSaleUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>;
                };
                deleteMany: {
                    args: Prisma.ProductSaleDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProductSaleUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProductSaleUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>[];
                };
                upsert: {
                    args: Prisma.ProductSaleUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSalePayload>;
                };
                aggregate: {
                    args: Prisma.ProductSaleAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProductSale>;
                };
                groupBy: {
                    args: Prisma.ProductSaleGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProductSaleGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProductSaleCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProductSaleCountAggregateOutputType>
                        | number;
                };
            };
        };
        Order: {
            payload: Prisma.$OrderPayload<ExtArgs>;
            fields: Prisma.OrderFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.OrderFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>;
                };
                findFirst: {
                    args: Prisma.OrderFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>;
                };
                findMany: {
                    args: Prisma.OrderFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[];
                };
                create: {
                    args: Prisma.OrderCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>;
                };
                createMany: {
                    args: Prisma.OrderCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[];
                };
                delete: {
                    args: Prisma.OrderDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>;
                };
                update: {
                    args: Prisma.OrderUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>;
                };
                deleteMany: {
                    args: Prisma.OrderDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.OrderUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[];
                };
                upsert: {
                    args: Prisma.OrderUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>;
                };
                aggregate: {
                    args: Prisma.OrderAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateOrder>;
                };
                groupBy: {
                    args: Prisma.OrderGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.OrderGroupByOutputType>[];
                };
                count: {
                    args: Prisma.OrderCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.OrderCountAggregateOutputType>
                        | number;
                };
            };
        };
        OrderItem: {
            payload: Prisma.$OrderItemPayload<ExtArgs>;
            fields: Prisma.OrderItemFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.OrderItemFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>;
                };
                findFirst: {
                    args: Prisma.OrderItemFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>;
                };
                findMany: {
                    args: Prisma.OrderItemFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
                };
                create: {
                    args: Prisma.OrderItemCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>;
                };
                createMany: {
                    args: Prisma.OrderItemCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
                };
                delete: {
                    args: Prisma.OrderItemDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>;
                };
                update: {
                    args: Prisma.OrderItemUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>;
                };
                deleteMany: {
                    args: Prisma.OrderItemDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.OrderItemUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
                };
                upsert: {
                    args: Prisma.OrderItemUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>;
                };
                aggregate: {
                    args: Prisma.OrderItemAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateOrderItem>;
                };
                groupBy: {
                    args: Prisma.OrderItemGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.OrderItemGroupByOutputType>[];
                };
                count: {
                    args: Prisma.OrderItemCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.OrderItemCountAggregateOutputType>
                        | number;
                };
            };
        };
        Expense: {
            payload: Prisma.$ExpensePayload<ExtArgs>;
            fields: Prisma.ExpenseFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ExpenseFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
                };
                findFirst: {
                    args: Prisma.ExpenseFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
                };
                findMany: {
                    args: Prisma.ExpenseFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[];
                };
                create: {
                    args: Prisma.ExpenseCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
                };
                createMany: {
                    args: Prisma.ExpenseCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[];
                };
                delete: {
                    args: Prisma.ExpenseDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
                };
                update: {
                    args: Prisma.ExpenseUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
                };
                deleteMany: {
                    args: Prisma.ExpenseDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ExpenseUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[];
                };
                upsert: {
                    args: Prisma.ExpenseUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
                };
                aggregate: {
                    args: Prisma.ExpenseAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateExpense>;
                };
                groupBy: {
                    args: Prisma.ExpenseGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ExpenseGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ExpenseCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ExpenseCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProfessionalWeeklyAvailability: {
            payload: Prisma.$ProfessionalWeeklyAvailabilityPayload<ExtArgs>;
            fields: Prisma.ProfessionalWeeklyAvailabilityFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalWeeklyAvailabilityFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalWeeklyAvailabilityFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalWeeklyAvailabilityFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalWeeklyAvailabilityFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalWeeklyAvailabilityFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>[];
                };
                create: {
                    args: Prisma.ProfessionalWeeklyAvailabilityCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalWeeklyAvailabilityCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalWeeklyAvailabilityCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalWeeklyAvailabilityDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>;
                };
                update: {
                    args: Prisma.ProfessionalWeeklyAvailabilityUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalWeeklyAvailabilityDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalWeeklyAvailabilityUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalWeeklyAvailabilityUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalWeeklyAvailabilityUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyAvailabilityPayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalWeeklyAvailabilityAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessionalWeeklyAvailability>;
                };
                groupBy: {
                    args: Prisma.ProfessionalWeeklyAvailabilityGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalWeeklyAvailabilityGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalWeeklyAvailabilityCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalWeeklyAvailabilityCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProfessionalWeeklyTimeInterval: {
            payload: Prisma.$ProfessionalWeeklyTimeIntervalPayload<ExtArgs>;
            fields: Prisma.ProfessionalWeeklyTimeIntervalFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>[];
                };
                create: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>;
                };
                update: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalWeeklyTimeIntervalPayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessionalWeeklyTimeInterval>;
                };
                groupBy: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalWeeklyTimeIntervalGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalWeeklyTimeIntervalCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalWeeklyTimeIntervalCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProfessionalDailyAvailability: {
            payload: Prisma.$ProfessionalDailyAvailabilityPayload<ExtArgs>;
            fields: Prisma.ProfessionalDailyAvailabilityFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalDailyAvailabilityFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalDailyAvailabilityFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalDailyAvailabilityFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalDailyAvailabilityFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalDailyAvailabilityFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>[];
                };
                create: {
                    args: Prisma.ProfessionalDailyAvailabilityCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalDailyAvailabilityCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalDailyAvailabilityCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalDailyAvailabilityDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>;
                };
                update: {
                    args: Prisma.ProfessionalDailyAvailabilityUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalDailyAvailabilityDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalDailyAvailabilityUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalDailyAvailabilityUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalDailyAvailabilityUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyAvailabilityPayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalDailyAvailabilityAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessionalDailyAvailability>;
                };
                groupBy: {
                    args: Prisma.ProfessionalDailyAvailabilityGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalDailyAvailabilityGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalDailyAvailabilityCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalDailyAvailabilityCountAggregateOutputType>
                        | number;
                };
            };
        };
        ProfessionalDailyTimeInterval: {
            payload: Prisma.$ProfessionalDailyTimeIntervalPayload<ExtArgs>;
            fields: Prisma.ProfessionalDailyTimeIntervalFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ProfessionalDailyTimeIntervalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ProfessionalDailyTimeIntervalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>;
                };
                findFirst: {
                    args: Prisma.ProfessionalDailyTimeIntervalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ProfessionalDailyTimeIntervalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>;
                };
                findMany: {
                    args: Prisma.ProfessionalDailyTimeIntervalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>[];
                };
                create: {
                    args: Prisma.ProfessionalDailyTimeIntervalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>;
                };
                createMany: {
                    args: Prisma.ProfessionalDailyTimeIntervalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ProfessionalDailyTimeIntervalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>[];
                };
                delete: {
                    args: Prisma.ProfessionalDailyTimeIntervalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>;
                };
                update: {
                    args: Prisma.ProfessionalDailyTimeIntervalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>;
                };
                deleteMany: {
                    args: Prisma.ProfessionalDailyTimeIntervalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ProfessionalDailyTimeIntervalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ProfessionalDailyTimeIntervalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>[];
                };
                upsert: {
                    args: Prisma.ProfessionalDailyTimeIntervalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfessionalDailyTimeIntervalPayload>;
                };
                aggregate: {
                    args: Prisma.ProfessionalDailyTimeIntervalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateProfessionalDailyTimeInterval>;
                };
                groupBy: {
                    args: Prisma.ProfessionalDailyTimeIntervalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ProfessionalDailyTimeIntervalGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ProfessionalDailyTimeIntervalCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ProfessionalDailyTimeIntervalCountAggregateOutputType>
                        | number;
                };
            };
        };
        AppointmentReview: {
            payload: Prisma.$AppointmentReviewPayload<ExtArgs>;
            fields: Prisma.AppointmentReviewFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.AppointmentReviewFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.AppointmentReviewFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>;
                };
                findFirst: {
                    args: Prisma.AppointmentReviewFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.AppointmentReviewFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>;
                };
                findMany: {
                    args: Prisma.AppointmentReviewFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>[];
                };
                create: {
                    args: Prisma.AppointmentReviewCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>;
                };
                createMany: {
                    args: Prisma.AppointmentReviewCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.AppointmentReviewCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>[];
                };
                delete: {
                    args: Prisma.AppointmentReviewDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>;
                };
                update: {
                    args: Prisma.AppointmentReviewUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>;
                };
                deleteMany: {
                    args: Prisma.AppointmentReviewDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.AppointmentReviewUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.AppointmentReviewUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>[];
                };
                upsert: {
                    args: Prisma.AppointmentReviewUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewPayload>;
                };
                aggregate: {
                    args: Prisma.AppointmentReviewAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateAppointmentReview>;
                };
                groupBy: {
                    args: Prisma.AppointmentReviewGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AppointmentReviewGroupByOutputType>[];
                };
                count: {
                    args: Prisma.AppointmentReviewCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.AppointmentReviewCountAggregateOutputType>
                        | number;
                };
            };
        };
        ReviewTag: {
            payload: Prisma.$ReviewTagPayload<ExtArgs>;
            fields: Prisma.ReviewTagFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.ReviewTagFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.ReviewTagFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>;
                };
                findFirst: {
                    args: Prisma.ReviewTagFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.ReviewTagFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>;
                };
                findMany: {
                    args: Prisma.ReviewTagFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>[];
                };
                create: {
                    args: Prisma.ReviewTagCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>;
                };
                createMany: {
                    args: Prisma.ReviewTagCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.ReviewTagCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>[];
                };
                delete: {
                    args: Prisma.ReviewTagDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>;
                };
                update: {
                    args: Prisma.ReviewTagUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>;
                };
                deleteMany: {
                    args: Prisma.ReviewTagDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.ReviewTagUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.ReviewTagUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>[];
                };
                upsert: {
                    args: Prisma.ReviewTagUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewTagPayload>;
                };
                aggregate: {
                    args: Prisma.ReviewTagAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateReviewTag>;
                };
                groupBy: {
                    args: Prisma.ReviewTagGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.ReviewTagGroupByOutputType>[];
                };
                count: {
                    args: Prisma.ReviewTagCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.ReviewTagCountAggregateOutputType>
                        | number;
                };
            };
        };
        AppointmentReviewTag: {
            payload: Prisma.$AppointmentReviewTagPayload<ExtArgs>;
            fields: Prisma.AppointmentReviewTagFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.AppointmentReviewTagFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.AppointmentReviewTagFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>;
                };
                findFirst: {
                    args: Prisma.AppointmentReviewTagFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.AppointmentReviewTagFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>;
                };
                findMany: {
                    args: Prisma.AppointmentReviewTagFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>[];
                };
                create: {
                    args: Prisma.AppointmentReviewTagCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>;
                };
                createMany: {
                    args: Prisma.AppointmentReviewTagCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.AppointmentReviewTagCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>[];
                };
                delete: {
                    args: Prisma.AppointmentReviewTagDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>;
                };
                update: {
                    args: Prisma.AppointmentReviewTagUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>;
                };
                deleteMany: {
                    args: Prisma.AppointmentReviewTagDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.AppointmentReviewTagUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.AppointmentReviewTagUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>[];
                };
                upsert: {
                    args: Prisma.AppointmentReviewTagUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentReviewTagPayload>;
                };
                aggregate: {
                    args: Prisma.AppointmentReviewTagAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateAppointmentReviewTag>;
                };
                groupBy: {
                    args: Prisma.AppointmentReviewTagGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AppointmentReviewTagGroupByOutputType>[];
                };
                count: {
                    args: Prisma.AppointmentReviewTagCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.AppointmentReviewTagCountAggregateOutputType>
                        | number;
                };
            };
        };
        AdminAccess: {
            payload: Prisma.$AdminAccessPayload<ExtArgs>;
            fields: Prisma.AdminAccessFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.AdminAccessFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.AdminAccessFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>;
                };
                findFirst: {
                    args: Prisma.AdminAccessFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.AdminAccessFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>;
                };
                findMany: {
                    args: Prisma.AdminAccessFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>[];
                };
                create: {
                    args: Prisma.AdminAccessCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>;
                };
                createMany: {
                    args: Prisma.AdminAccessCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.AdminAccessCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>[];
                };
                delete: {
                    args: Prisma.AdminAccessDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>;
                };
                update: {
                    args: Prisma.AdminAccessUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>;
                };
                deleteMany: {
                    args: Prisma.AdminAccessDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.AdminAccessUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.AdminAccessUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>[];
                };
                upsert: {
                    args: Prisma.AdminAccessUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminAccessPayload>;
                };
                aggregate: {
                    args: Prisma.AdminAccessAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateAdminAccess>;
                };
                groupBy: {
                    args: Prisma.AdminAccessGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AdminAccessGroupByOutputType>[];
                };
                count: {
                    args: Prisma.AdminAccessCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.AdminAccessCountAggregateOutputType>
                        | number;
                };
            };
        };
        AnalyticsEvent: {
            payload: Prisma.$AnalyticsEventPayload<ExtArgs>;
            fields: Prisma.AnalyticsEventFieldRefs;
            operations: {
                findUnique: {
                    args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null;
                };
                findUniqueOrThrow: {
                    args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>;
                };
                findFirst: {
                    args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null;
                };
                findFirstOrThrow: {
                    args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>;
                };
                findMany: {
                    args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[];
                };
                create: {
                    args: Prisma.AnalyticsEventCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>;
                };
                createMany: {
                    args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[];
                };
                delete: {
                    args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>;
                };
                update: {
                    args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>;
                };
                deleteMany: {
                    args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[];
                };
                upsert: {
                    args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>;
                };
                aggregate: {
                    args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AggregateAnalyticsEvent>;
                };
                groupBy: {
                    args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<Prisma.AnalyticsEventGroupByOutputType>[];
                };
                count: {
                    args: Prisma.AnalyticsEventCountArgs<ExtArgs>;
                    result:
                        | runtime.Types.Utils.Optional<Prisma.AnalyticsEventCountAggregateOutputType>
                        | number;
                };
            };
        };
    };
} & {
    other: {
        payload: any;
        operations: {
            $executeRaw: {
                args: [query: TemplateStringsArray | Sql, ...values: any[]];
                result: any;
            };
            $executeRawUnsafe: {
                args: [query: string, ...values: any[]];
                result: any;
            };
            $queryRaw: {
                args: [query: TemplateStringsArray | Sql, ...values: any[]];
                result: any;
            };
            $queryRawUnsafe: {
                args: [query: string, ...values: any[]];
                result: any;
            };
        };
    };
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
} as const);

export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const CompanyScalarFieldEnum = {
    id: 'id',
    name: 'name',
    slug: 'slug',
    segment: 'segment',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type CompanyScalarFieldEnum =
    (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum];

export const CompanyMemberScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    role: 'role',
    isActive: 'isActive',
    lastUnitId: 'lastUnitId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type CompanyMemberScalarFieldEnum =
    (typeof CompanyMemberScalarFieldEnum)[keyof typeof CompanyMemberScalarFieldEnum];

export const UserScalarFieldEnum = {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    phone: 'phone',
    passwordHash: 'passwordHash',
    birthday: 'birthday',
    role: 'role',
    isOwner: 'isOwner',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const AccountScalarFieldEnum = {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
} as const;

export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

export const SessionScalarFieldEnum = {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
} as const;

export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

export const VerificationTokenScalarFieldEnum = {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires',
} as const;

export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

export const UnitScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    phone: 'phone',
    address: 'address',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type UnitScalarFieldEnum =
    (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum];

export const CustomerLevelConfigScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    level: 'level',
    minAppointmentsDone: 'minAppointmentsDone',
    minOrdersCompleted: 'minOrdersCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type CustomerLevelConfigScalarFieldEnum =
    (typeof CustomerLevelConfigScalarFieldEnum)[keyof typeof CustomerLevelConfigScalarFieldEnum];

export const CustomerLevelRuleScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    type: 'type',
    targetLevel: 'targetLevel',
    priority: 'priority',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type CustomerLevelRuleScalarFieldEnum =
    (typeof CustomerLevelRuleScalarFieldEnum)[keyof typeof CustomerLevelRuleScalarFieldEnum];

export const CustomerLevelStateScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    userId: 'userId',
    levelCurrent: 'levelCurrent',
    levelEarnedLastPeriod: 'levelEarnedLastPeriod',
    levelEffectiveFrom: 'levelEffectiveFrom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type CustomerLevelStateScalarFieldEnum =
    (typeof CustomerLevelStateScalarFieldEnum)[keyof typeof CustomerLevelStateScalarFieldEnum];

export const CustomerLevelPeriodScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    userId: 'userId',
    periodKey: 'periodKey',
    appointmentsDone: 'appointmentsDone',
    ordersCompleted: 'ordersCompleted',
    earnedLevel: 'earnedLevel',
    computedAt: 'computedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type CustomerLevelPeriodScalarFieldEnum =
    (typeof CustomerLevelPeriodScalarFieldEnum)[keyof typeof CustomerLevelPeriodScalarFieldEnum];

export const ProfessionalUnitScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    professionalId: 'professionalId',
    unitId: 'unitId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProfessionalUnitScalarFieldEnum =
    (typeof ProfessionalUnitScalarFieldEnum)[keyof typeof ProfessionalUnitScalarFieldEnum];

export const UnitWeeklyAvailabilityScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    weekday: 'weekday',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type UnitWeeklyAvailabilityScalarFieldEnum =
    (typeof UnitWeeklyAvailabilityScalarFieldEnum)[keyof typeof UnitWeeklyAvailabilityScalarFieldEnum];

export const UnitWeeklyTimeIntervalScalarFieldEnum = {
    id: 'id',
    weeklyAvailabilityId: 'weeklyAvailabilityId',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type UnitWeeklyTimeIntervalScalarFieldEnum =
    (typeof UnitWeeklyTimeIntervalScalarFieldEnum)[keyof typeof UnitWeeklyTimeIntervalScalarFieldEnum];

export const UnitDailyAvailabilityScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    date: 'date',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type UnitDailyAvailabilityScalarFieldEnum =
    (typeof UnitDailyAvailabilityScalarFieldEnum)[keyof typeof UnitDailyAvailabilityScalarFieldEnum];

export const UnitDailyTimeIntervalScalarFieldEnum = {
    id: 'id',
    dailyAvailabilityId: 'dailyAvailabilityId',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type UnitDailyTimeIntervalScalarFieldEnum =
    (typeof UnitDailyTimeIntervalScalarFieldEnum)[keyof typeof UnitDailyTimeIntervalScalarFieldEnum];

export const ProfessionalScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    isActive: 'isActive',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
} as const;

export type ProfessionalScalarFieldEnum =
    (typeof ProfessionalScalarFieldEnum)[keyof typeof ProfessionalScalarFieldEnum];

export const ServiceScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    name: 'name',
    price: 'price',
    durationMinutes: 'durationMinutes',
    isActive: 'isActive',
    professionalPercentage: 'professionalPercentage',
    cancelLimitHours: 'cancelLimitHours',
    cancelFeePercentage: 'cancelFeePercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ServiceScalarFieldEnum =
    (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

export const ServiceProfessionalScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    serviceId: 'serviceId',
    professionalId: 'professionalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ServiceProfessionalScalarFieldEnum =
    (typeof ServiceProfessionalScalarFieldEnum)[keyof typeof ServiceProfessionalScalarFieldEnum];

export const PlanScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    description: 'description',
    price: 'price',
    durationDays: 'durationDays',
    totalBookings: 'totalBookings',
    commissionPercent: 'commissionPercent',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type PlanScalarFieldEnum =
    (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum];

export const PlanServiceScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    planId: 'planId',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type PlanServiceScalarFieldEnum =
    (typeof PlanServiceScalarFieldEnum)[keyof typeof PlanServiceScalarFieldEnum];

export const ClientPlanScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    clientId: 'clientId',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate',
    usedBookings: 'usedBookings',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ClientPlanScalarFieldEnum =
    (typeof ClientPlanScalarFieldEnum)[keyof typeof ClientPlanScalarFieldEnum];

export const AppointmentScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    description: 'description',
    clientName: 'clientName',
    phone: 'phone',
    scheduleAt: 'scheduleAt',
    status: 'status',
    clientId: 'clientId',
    professionalId: 'professionalId',
    serviceId: 'serviceId',
    servicePriceAtTheTime: 'servicePriceAtTheTime',
    professionalPercentageAtTheTime: 'professionalPercentageAtTheTime',
    professionalEarningValue: 'professionalEarningValue',
    cancelFeeApplied: 'cancelFeeApplied',
    cancelFeeValue: 'cancelFeeValue',
    cancelledByRole: 'cancelledByRole',
    concludedByRole: 'concludedByRole',
    cancelledAt: 'cancelledAt',
    doneAt: 'doneAt',
    checkedOutAt: 'checkedOutAt',
    checkoutFinancialSnapshot: 'checkoutFinancialSnapshot',
    checkedOutByUserId: 'checkedOutByUserId',
    concludedByUserId: 'concludedByUserId',
    concludedByProfessionalId: 'concludedByProfessionalId',
    cancelledByUserId: 'cancelledByUserId',
    cancelledByProfessionalId: 'cancelledByProfessionalId',
    clientPlanId: 'clientPlanId',
    reviewModalShown: 'reviewModalShown',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type AppointmentScalarFieldEnum =
    (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum];

export const ProfessionalCancellationFeeScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    appointmentId: 'appointmentId',
    professionalId: 'professionalId',
    unitId: 'unitId',
    amount: 'amount',
    createdAt: 'createdAt',
} as const;

export type ProfessionalCancellationFeeScalarFieldEnum =
    (typeof ProfessionalCancellationFeeScalarFieldEnum)[keyof typeof ProfessionalCancellationFeeScalarFieldEnum];

export const ProductScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    name: 'name',
    imageUrl: 'imageUrl',
    description: 'description',
    price: 'price',
    professionalPercentage: 'professionalPercentage',
    category: 'category',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    stockQuantity: 'stockQuantity',
    pickupDeadlineDays: 'pickupDeadlineDays',
    birthdayBenefitEnabled: 'birthdayBenefitEnabled',
    birthdayPriceLevel: 'birthdayPriceLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProductScalarFieldEnum =
    (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum];

export const ProductDiscountByLevelScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    productId: 'productId',
    level: 'level',
    discountPct: 'discountPct',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProductDiscountByLevelScalarFieldEnum =
    (typeof ProductDiscountByLevelScalarFieldEnum)[keyof typeof ProductDiscountByLevelScalarFieldEnum];

export const ProductSaleScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    productId: 'productId',
    professionalId: 'professionalId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    soldAt: 'soldAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProductSaleScalarFieldEnum =
    (typeof ProductSaleScalarFieldEnum)[keyof typeof ProductSaleScalarFieldEnum];

export const OrderScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    clientId: 'clientId',
    appointmentId: 'appointmentId',
    professionalId: 'professionalId',
    status: 'status',
    reservedUntil: 'reservedUntil',
    expiredAt: 'expiredAt',
    inventoryRevertedAt: 'inventoryRevertedAt',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type OrderScalarFieldEnum =
    (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum];

export const OrderItemScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    orderId: 'orderId',
    productId: 'productId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type OrderItemScalarFieldEnum =
    (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum];

export const ExpenseScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    unitId: 'unitId',
    description: 'description',
    category: 'category',
    amount: 'amount',
    dueDate: 'dueDate',
    isRecurring: 'isRecurring',
    isPaid: 'isPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ExpenseScalarFieldEnum =
    (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum];

export const ProfessionalWeeklyAvailabilityScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    professionalId: 'professionalId',
    unitId: 'unitId',
    weekday: 'weekday',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProfessionalWeeklyAvailabilityScalarFieldEnum =
    (typeof ProfessionalWeeklyAvailabilityScalarFieldEnum)[keyof typeof ProfessionalWeeklyAvailabilityScalarFieldEnum];

export const ProfessionalWeeklyTimeIntervalScalarFieldEnum = {
    id: 'id',
    weeklyAvailabilityId: 'weeklyAvailabilityId',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProfessionalWeeklyTimeIntervalScalarFieldEnum =
    (typeof ProfessionalWeeklyTimeIntervalScalarFieldEnum)[keyof typeof ProfessionalWeeklyTimeIntervalScalarFieldEnum];

export const ProfessionalDailyAvailabilityScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    professionalId: 'professionalId',
    unitId: 'unitId',
    date: 'date',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProfessionalDailyAvailabilityScalarFieldEnum =
    (typeof ProfessionalDailyAvailabilityScalarFieldEnum)[keyof typeof ProfessionalDailyAvailabilityScalarFieldEnum];

export const ProfessionalDailyTimeIntervalScalarFieldEnum = {
    id: 'id',
    dailyAvailabilityId: 'dailyAvailabilityId',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ProfessionalDailyTimeIntervalScalarFieldEnum =
    (typeof ProfessionalDailyTimeIntervalScalarFieldEnum)[keyof typeof ProfessionalDailyTimeIntervalScalarFieldEnum];

export const AppointmentReviewScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    appointmentId: 'appointmentId',
    clientId: 'clientId',
    professionalId: 'professionalId',
    rating: 'rating',
    comment: 'comment',
    isAnonymousForProfessional: 'isAnonymousForProfessional',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type AppointmentReviewScalarFieldEnum =
    (typeof AppointmentReviewScalarFieldEnum)[keyof typeof AppointmentReviewScalarFieldEnum];

export const ReviewTagScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    label: 'label',
    isActive: 'isActive',
    isNegative: 'isNegative',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type ReviewTagScalarFieldEnum =
    (typeof ReviewTagScalarFieldEnum)[keyof typeof ReviewTagScalarFieldEnum];

export const AppointmentReviewTagScalarFieldEnum = {
    id: 'id',
    reviewId: 'reviewId',
    tagId: 'tagId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type AppointmentReviewTagScalarFieldEnum =
    (typeof AppointmentReviewTagScalarFieldEnum)[keyof typeof AppointmentReviewTagScalarFieldEnum];

export const AdminAccessScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    unitId: 'unitId',
    canAccessDashboard: 'canAccessDashboard',
    canAccessReports: 'canAccessReports',
    canAccessCheckout: 'canAccessCheckout',
    canAccessAppointments: 'canAccessAppointments',
    canAccessProfessionals: 'canAccessProfessionals',
    canAccessServices: 'canAccessServices',
    canAccessReviews: 'canAccessReviews',
    canAccessProducts: 'canAccessProducts',
    canAccessClients: 'canAccessClients',
    canAccessClientLevels: 'canAccessClientLevels',
    canAccessFinance: 'canAccessFinance',
    canAccessSettings: 'canAccessSettings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
} as const;

export type AdminAccessScalarFieldEnum =
    (typeof AdminAccessScalarFieldEnum)[keyof typeof AdminAccessScalarFieldEnum];

export const AnalyticsEventScalarFieldEnum = {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    unitId: 'unitId',
    name: 'name',
    ts: 'ts',
    source: 'source',
    pushId: 'pushId',
    pushType: 'pushType',
    secondsSincePush: 'secondsSincePush',
    payload: 'payload',
    context: 'context',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
} as const;

export type AnalyticsEventScalarFieldEnum =
    (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum];

export const SortOrder = {
    asc: 'asc',
    desc: 'desc',
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const NullableJsonNullValueInput = {
    DbNull: DbNull,
    JsonNull: JsonNull,
} as const;

export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

export const QueryMode = {
    default: 'default',
    insensitive: 'insensitive',
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const NullsOrder = {
    first: 'first',
    last: 'last',
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

export const JsonNullValueFilter = {
    DbNull: DbNull,
    JsonNull: JsonNull,
    AnyNull: AnyNull,
} as const;

export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
>;

/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
>;

/**
 * Reference to a field of type 'CompanySegment'
 */
export type EnumCompanySegmentFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'CompanySegment'
>;

/**
 * Reference to a field of type 'CompanySegment[]'
 */
export type ListEnumCompanySegmentFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CompanySegment[]'>;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
>;

/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
>;

/**
 * Reference to a field of type 'CompanyMemberRole'
 */
export type EnumCompanyMemberRoleFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CompanyMemberRole'>;

/**
 * Reference to a field of type 'CompanyMemberRole[]'
 */
export type ListEnumCompanyMemberRoleFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CompanyMemberRole[]'>;

/**
 * Reference to a field of type 'Role'
 */
export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Role'
>;

/**
 * Reference to a field of type 'Role[]'
 */
export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Role[]'
>;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
>;

/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
>;

/**
 * Reference to a field of type 'CustomerLevel'
 */
export type EnumCustomerLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'CustomerLevel'
>;

/**
 * Reference to a field of type 'CustomerLevel[]'
 */
export type ListEnumCustomerLevelFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CustomerLevel[]'>;

/**
 * Reference to a field of type 'CustomerLevelRuleType'
 */
export type EnumCustomerLevelRuleTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CustomerLevelRuleType'>;

/**
 * Reference to a field of type 'CustomerLevelRuleType[]'
 */
export type ListEnumCustomerLevelRuleTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'CustomerLevelRuleType[]'>;

/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
>;

/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal[]'
>;

/**
 * Reference to a field of type 'ClientPlanStatus'
 */
export type EnumClientPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ClientPlanStatus'
>;

/**
 * Reference to a field of type 'ClientPlanStatus[]'
 */
export type ListEnumClientPlanStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ClientPlanStatus[]'>;

/**
 * Reference to a field of type 'AppointmentStatus'
 */
export type EnumAppointmentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'AppointmentStatus'>;

/**
 * Reference to a field of type 'AppointmentStatus[]'
 */
export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>;

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
>;

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
>;

/**
 * Reference to a field of type 'OrderStatus'
 */
export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'OrderStatus'
>;

/**
 * Reference to a field of type 'OrderStatus[]'
 */
export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'OrderStatus[]'
>;

/**
 * Reference to a field of type 'ExpenseCategory'
 */
export type EnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ExpenseCategory'
>;

/**
 * Reference to a field of type 'ExpenseCategory[]'
 */
export type ListEnumExpenseCategoryFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ExpenseCategory[]'>;

/**
 * Reference to a field of type 'ProfessionalDailyAvailabilityType'
 */
export type EnumProfessionalDailyAvailabilityTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ProfessionalDailyAvailabilityType'>;

/**
 * Reference to a field of type 'ProfessionalDailyAvailabilityType[]'
 */
export type ListEnumProfessionalDailyAvailabilityTypeFieldRefInput<
    $PrismaModel,
> = FieldRefInputType<$PrismaModel, 'ProfessionalDailyAvailabilityType[]'>;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
>;

/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
>;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
    count: number;
};

export type Datasource = {
    url?: string;
};
export type Datasources = {
    db?: Datasource;
};

export const defineExtension = runtime.Extensions
    .defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
    'define',
    TypeMapCb,
    runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
        maxWait?: number;
        timeout?: number;
        isolationLevel?: TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: GlobalOmitConfig;
}
export type GlobalOmitConfig = {
    company?: Prisma.CompanyOmit;
    companyMember?: Prisma.CompanyMemberOmit;
    user?: Prisma.UserOmit;
    account?: Prisma.AccountOmit;
    session?: Prisma.SessionOmit;
    verificationToken?: Prisma.VerificationTokenOmit;
    unit?: Prisma.UnitOmit;
    customerLevelConfig?: Prisma.CustomerLevelConfigOmit;
    customerLevelRule?: Prisma.CustomerLevelRuleOmit;
    customerLevelState?: Prisma.CustomerLevelStateOmit;
    customerLevelPeriod?: Prisma.CustomerLevelPeriodOmit;
    professionalUnit?: Prisma.ProfessionalUnitOmit;
    unitWeeklyAvailability?: Prisma.UnitWeeklyAvailabilityOmit;
    unitWeeklyTimeInterval?: Prisma.UnitWeeklyTimeIntervalOmit;
    unitDailyAvailability?: Prisma.UnitDailyAvailabilityOmit;
    unitDailyTimeInterval?: Prisma.UnitDailyTimeIntervalOmit;
    professional?: Prisma.ProfessionalOmit;
    service?: Prisma.ServiceOmit;
    serviceProfessional?: Prisma.ServiceProfessionalOmit;
    plan?: Prisma.PlanOmit;
    planService?: Prisma.PlanServiceOmit;
    clientPlan?: Prisma.ClientPlanOmit;
    appointment?: Prisma.AppointmentOmit;
    professionalCancellationFee?: Prisma.ProfessionalCancellationFeeOmit;
    product?: Prisma.ProductOmit;
    productDiscountByLevel?: Prisma.ProductDiscountByLevelOmit;
    productSale?: Prisma.ProductSaleOmit;
    order?: Prisma.OrderOmit;
    orderItem?: Prisma.OrderItemOmit;
    expense?: Prisma.ExpenseOmit;
    professionalWeeklyAvailability?: Prisma.ProfessionalWeeklyAvailabilityOmit;
    professionalWeeklyTimeInterval?: Prisma.ProfessionalWeeklyTimeIntervalOmit;
    professionalDailyAvailability?: Prisma.ProfessionalDailyAvailabilityOmit;
    professionalDailyTimeInterval?: Prisma.ProfessionalDailyTimeIntervalOmit;
    appointmentReview?: Prisma.AppointmentReviewOmit;
    reviewTag?: Prisma.ReviewTagOmit;
    appointmentReviewTag?: Prisma.AppointmentReviewTagOmit;
    adminAccess?: Prisma.AdminAccessOmit;
    analyticsEvent?: Prisma.AnalyticsEventOmit;
};

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error';
export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
};

export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
};
/* End Types for Logging */

export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
    DefaultPrismaClient,
    runtime.ITXClientDenyList
>;
